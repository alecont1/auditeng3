---
phase: 06-reporting-audit
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - app/db/models/audit_log.py
  - app/db/models/__init__.py
  - alembic/versions/xxxx_add_audit_log.py
  - app/services/audit.py
  - app/services/__init__.py
  - app/worker/extraction.py
  - app/tests/services/test_audit.py
autonomous: true

must_haves:
  truths:
    - "AuditLog records are created during extraction"
    - "AuditLog records are created during validation"
    - "Each log includes timestamp, event_type, and details"
    - "Logs include model_version and prompt_version for AI events"
    - "Logs include confidence_score for extraction events"
  artifacts:
    - path: "app/db/models/audit_log.py"
      provides: "AuditLog ORM model"
      contains: "class AuditLog"
    - path: "app/services/audit.py"
      provides: "AuditService for logging"
      exports: ["AuditService", "log_event"]
  key_links:
    - from: "app/worker/extraction.py"
      to: "AuditService"
      via: "log_event calls"
      pattern: "log_event|AuditService"
---

<objective>
Create audit logging infrastructure for extraction and validation events.

Purpose: Enable compliance traceability (AUDT-01 to AUDT-05). Every extraction attempt, validation decision, and AI model usage is logged with timestamps. Logs are append-only for immutability.

Output: AuditLog model, AuditService, and integration with extraction worker.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-reporting-audit/06-CONTEXT.md

# Existing patterns
@app/db/models/analysis.py
@app/db/base.py
@app/worker/extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuditLog model and migration</name>
  <files>app/db/models/audit_log.py, app/db/models/__init__.py</files>
  <action>
Create app/db/models/audit_log.py:

1. AuditLog model with fields:
   - id: UUID primary key (uuid4 default)
   - analysis_id: UUID foreign key to analyses.id (nullable, some events may be pre-analysis)
   - event_type: String(50) NOT NULL - e.g., "extraction_started", "extraction_completed", "validation_rule_applied", "finding_generated"
   - event_timestamp: DateTime NOT NULL with server_default=func.now()
   - details: JSON - flexible storage for event-specific data
   - model_version: String(100) nullable - Claude model used (e.g., "claude-sonnet-4-20250514")
   - prompt_version: String(50) nullable - internal prompt version (e.g., "grounding_v1")
   - confidence_score: Float nullable - extraction confidence
   - rule_id: String(100) nullable - validation rule that triggered
   - created_at: DateTime (from TimestampMixin)

2. Add index on (analysis_id, event_timestamp) for efficient queries
3. Table constraint: no UPDATE or DELETE triggers (append-only enforced at app level, DB constraint optional)

4. Update app/db/models/__init__.py to export AuditLog

Create migration:
```bash
cd /home/xande && alembic revision --autogenerate -m "add_audit_log_table"
```

Then run: `alembic upgrade head`
  </action>
  <verify>cd /home/xande && alembic upgrade head && python -c "from app.db.models import AuditLog; print('OK')"</verify>
  <done>AuditLog model created, migration applied</done>
</task>

<task type="auto">
  <name>Task 2: Create AuditService for logging events</name>
  <files>app/services/audit.py, app/services/__init__.py</files>
  <action>
Create app/services/audit.py:

1. EventType StrEnum:
   - EXTRACTION_STARTED = "extraction_started"
   - EXTRACTION_COMPLETED = "extraction_completed"
   - EXTRACTION_FAILED = "extraction_failed"
   - VALIDATION_STARTED = "validation_started"
   - VALIDATION_RULE_APPLIED = "validation_rule_applied"
   - FINDING_GENERATED = "finding_generated"
   - VALIDATION_COMPLETED = "validation_completed"

2. AuditService class with static methods:
   - log_extraction_start(db, analysis_id, model_version, prompt_version) -> AuditLog
   - log_extraction_complete(db, analysis_id, confidence_score, field_count) -> AuditLog
   - log_extraction_failed(db, analysis_id, error_message) -> AuditLog
   - log_validation_rule(db, analysis_id, rule_id, passed: bool, details) -> AuditLog
   - log_finding_generated(db, analysis_id, rule_id, severity, message) -> AuditLog
   - log_validation_complete(db, analysis_id, verdict, compliance_score) -> AuditLog
   - get_audit_trail(db, analysis_id) -> list[AuditLog] (ordered by timestamp)

3. Convenience function: async def log_event(db, event_type, analysis_id, **kwargs) -> AuditLog
   - Creates AuditLog record with current timestamp
   - Stores kwargs in details JSON field
   - Does NOT call db.commit() - caller controls transaction

4. Export from app/services/__init__.py

IMPORTANT: All log methods are append-only. Never update or delete AuditLog records.
  </action>
  <verify>python -c "from app.services.audit import AuditService, EventType, log_event; print('OK')"</verify>
  <done>AuditService with event logging methods</done>
</task>

<task type="auto">
  <name>Task 3: Integrate audit logging into extraction worker</name>
  <files>app/worker/extraction.py</files>
  <action>
Update app/worker/extraction.py to log audit events:

1. Import AuditService, EventType from app.services.audit

2. In process_document_task function, add logging:
   a. After analysis created, before extraction:
      - AuditService.log_extraction_start(db, analysis.id, model_version="claude-sonnet-4", prompt_version=f"{test_type}_v1")

   b. After extraction succeeds:
      - AuditService.log_extraction_complete(db, analysis.id, confidence_score=extraction_result.confidence, field_count=len(extracted_fields))

   c. On extraction failure:
      - AuditService.log_extraction_failed(db, analysis.id, error_message=str(e))

   d. During validation (in orchestrator or after validation):
      - For each finding generated: AuditService.log_finding_generated(...)

   e. After validation complete:
      - AuditService.log_validation_complete(db, analysis.id, verdict=verdict, compliance_score=score)

3. Wrap audit logging in try/except - audit failures should NOT fail the main task (log warning and continue)

The extraction worker already has the db session, so pass it to audit methods.
Model version can be retrieved from config or hardcoded for now (config.CLAUDE_MODEL or "claude-sonnet-4").
  </action>
  <verify>python -c "from app.worker.extraction import process_document_task; print('OK')"</verify>
  <done>Extraction worker logs audit events for extraction and validation</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for audit service</name>
  <files>app/tests/services/test_audit.py</files>
  <action>
Create tests for AuditService:

1. test_log_event_creates_record:
   - Call log_event with event_type and details
   - Assert AuditLog record created with correct fields

2. test_log_extraction_start:
   - Call log_extraction_start
   - Assert event_type is EXTRACTION_STARTED
   - Assert model_version and prompt_version stored

3. test_log_extraction_complete:
   - Call log_extraction_complete with confidence_score
   - Assert confidence_score stored

4. test_log_validation_rule:
   - Call log_validation_rule with rule_id and passed=True
   - Assert details contains passed status

5. test_log_finding_generated:
   - Call log_finding_generated with rule_id, severity, message
   - Assert rule_id stored
   - Assert details contains severity and message

6. test_get_audit_trail_ordered:
   - Create multiple audit logs with different timestamps
   - Call get_audit_trail
   - Assert returned in chronological order

7. test_audit_logs_are_immutable:
   - Create audit log
   - Verify no update method exists on AuditService
   - Document that app-level immutability is enforced (no DB triggers needed for MVP)

Use async test fixtures with test database session.
  </action>
  <verify>cd /home/xande && python -m pytest app/tests/services/test_audit.py -v</verify>
  <done>7 tests passing for AuditService</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `alembic upgrade head` succeeds
- [ ] `python -c "from app.db.models import AuditLog"` works
- [ ] `python -c "from app.services.audit import AuditService"` works
- [ ] `python -m pytest app/tests/services/test_audit.py -v` passes all tests
- [ ] Extraction worker imports and uses AuditService without errors
</verification>

<success_criteria>
- All tasks completed
- AuditLog model with appropriate fields
- Migration applied successfully
- AuditService provides event logging methods
- Extraction worker logs extraction and validation events
- Audit logs are append-only (no update/delete methods)
- 7 unit tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/06-reporting-audit/06-03-SUMMARY.md`
</output>
