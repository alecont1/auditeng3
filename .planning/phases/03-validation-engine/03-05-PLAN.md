---
phase: 03-validation-engine
plan: 05
type: execute
wave: 3
depends_on: [03-02, 03-03, 03-04]
files_modified: [app/core/validation/calibration.py, app/core/validation/cross_field.py]
autonomous: true

must_haves:
  truths:
    - "Calibration expiration validated (no expired allowed)"
    - "Equipment TAG consistency validated across document"
    - "Measurement units presence validated"
  artifacts:
    - path: "app/core/validation/calibration.py"
      provides: "CalibrationValidator class"
      exports: ["CalibrationValidator"]
    - path: "app/core/validation/cross_field.py"
      provides: "CrossFieldValidator class"
      exports: ["CrossFieldValidator"]
  key_links:
    - from: "calibration.py"
      to: "base.py"
      via: "extends BaseValidator"
---

<objective>
Create validators for calibration certificates and cross-field consistency.

Purpose: Validate calibration dates and field consistency (VALD-04, VALD-05, VALD-06).
Output: CalibrationValidator and CrossFieldValidator classes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-validation-engine/03-01-SUMMARY.md

Requirements this plan addresses:
- VALD-04: System validates calibration certificate expiration dates
- VALD-05: System performs cross-field validation (equipment TAG consistency)
- VALD-06: System validates measurement units are present and consistent

Calibration schema reference:
- CalibrationInfo from app/core/extraction/schemas.py
- Contains: expiration_date, certificate_number, calibration_date

Config reference:
- max_days_expired: 0 (no expired allowed)
- warn_days_before_expiry: 30
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalibrationValidator</name>
  <files>app/core/validation/calibration.py</files>
  <action>
Create CalibrationValidator that validates certificate expiration.

app/core/validation/calibration.py:
- Import datetime, timedelta
- Import from app.core.validation.base import BaseValidator
- Import from app.core.validation.schemas import Finding, ValidationResult, ValidationSeverity
- Import from app.core.extraction.schemas import CalibrationInfo

class CalibrationValidator(BaseValidator):
    """Validator for calibration certificate expiration."""

    @property
    def test_type(self) -> str:
        return "calibration"

    def validate_calibration(
        self,
        calibration: CalibrationInfo | None,
        test_date_str: str | None = None,
    ) -> list[Finding]:
        """Validate calibration info and return findings.

        Args:
            calibration: Calibration info from extraction.
            test_date_str: Optional test date to validate against.

        Returns:
            list[Finding]: Calibration validation findings.
        """
        findings: list[Finding] = []

        if calibration is None:
            self.add_finding(
                findings=findings,
                rule_id="CALIB-001",
                severity=ValidationSeverity.MAJOR,
                message="No calibration certificate information found",
                field_path="calibration",
                extracted_value=None,
                threshold="Calibration certificate required",
                remediation="Ensure calibration certificate is included in report",
            )
            return findings

        # Get expiration date
        exp_date = calibration.expiration_date.value
        if exp_date is None:
            self.add_finding(
                findings=findings,
                rule_id="CALIB-002",
                severity=ValidationSeverity.MAJOR,
                message="Calibration expiration date not found",
                field_path="calibration.expiration_date",
                extracted_value=None,
                threshold="Expiration date required",
                remediation="Verify calibration certificate includes expiration date",
            )
            return findings

        # Parse dates
        from datetime import datetime, date

        # Handle various date formats
        if isinstance(exp_date, (datetime, date)):
            expiration = exp_date if isinstance(exp_date, date) else exp_date.date()
        elif isinstance(exp_date, str):
            try:
                expiration = datetime.fromisoformat(exp_date.replace('/', '-')).date()
            except ValueError:
                self.add_finding(
                    findings=findings,
                    rule_id="CALIB-003",
                    severity=ValidationSeverity.MINOR,
                    message=f"Unable to parse expiration date: {exp_date}",
                    field_path="calibration.expiration_date",
                    extracted_value=exp_date,
                    threshold="Valid date format required",
                )
                return findings
        else:
            return findings

        # Use test date if provided, otherwise current date
        if test_date_str:
            try:
                reference_date = datetime.fromisoformat(test_date_str.replace('/', '-')).date()
            except ValueError:
                reference_date = date.today()
        else:
            reference_date = date.today()

        config = self.config.calibration
        days_until_expiry = (expiration - reference_date).days

        if days_until_expiry < 0:
            # Expired
            self.add_finding(
                findings=findings,
                rule_id="CALIB-004",
                severity=ValidationSeverity.CRITICAL,
                message=f"Calibration expired {abs(days_until_expiry)} days ago on {expiration}",
                field_path="calibration.expiration_date",
                extracted_value=str(expiration),
                threshold=f"max_days_expired={config.max_days_expired}",
                standard_reference="ISO/IEC 17025",
                remediation="Recalibrate instrument before use. Test results may be invalid.",
            )
        elif days_until_expiry <= config.warn_days_before_expiry:
            # Expiring soon
            self.add_finding(
                findings=findings,
                rule_id="CALIB-005",
                severity=ValidationSeverity.MINOR,
                message=f"Calibration expires in {days_until_expiry} days on {expiration}",
                field_path="calibration.expiration_date",
                extracted_value=str(expiration),
                threshold=f"warn_days={config.warn_days_before_expiry}",
                standard_reference="ISO/IEC 17025",
                remediation="Schedule recalibration before expiration",
            )
        else:
            # Valid
            self.add_finding(
                findings=findings,
                rule_id="CALIB-006",
                severity=ValidationSeverity.INFO,
                message=f"Calibration valid until {expiration} ({days_until_expiry} days remaining)",
                field_path="calibration.expiration_date",
                extracted_value=str(expiration),
                threshold="Not expired",
                standard_reference="ISO/IEC 17025",
            )

        return findings

    def validate(self, extraction) -> ValidationResult:
        """Validate extraction's calibration info."""
        calibration = getattr(extraction, 'calibration', None)
        test_conditions = getattr(extraction, 'test_conditions', None)
        test_date = None
        if test_conditions and hasattr(test_conditions, 'test_date'):
            test_date = test_conditions.test_date.value if test_conditions.test_date else None

        findings = self.validate_calibration(calibration, test_date)
        equipment_tag = None
        if hasattr(extraction, 'equipment'):
            equipment_tag = extraction.equipment.equipment_tag.value

        return self.create_result(findings, equipment_tag=equipment_tag)
  </action>
  <verify>python3 -c "from app.core.validation.calibration import CalibrationValidator; print('✓ CalibrationValidator imports')"</verify>
  <done>CalibrationValidator validates expiration dates</done>
</task>

<task type="auto">
  <name>Task 2: Create CrossFieldValidator</name>
  <files>app/core/validation/cross_field.py</files>
  <action>
Create CrossFieldValidator for field consistency checks.

app/core/validation/cross_field.py:
- Import from app.core.validation.base import BaseValidator
- Import from app.core.validation.schemas import Finding, ValidationResult, ValidationSeverity

class CrossFieldValidator(BaseValidator):
    """Validator for cross-field consistency checks."""

    @property
    def test_type(self) -> str:
        return "cross_field"

    def validate(self, extraction) -> ValidationResult:
        """Validate cross-field consistency."""
        findings: list[Finding] = []
        equipment_tag = None

        if hasattr(extraction, 'equipment'):
            equipment_tag = extraction.equipment.equipment_tag.value

            # Validate equipment TAG is present
            if not equipment_tag or equipment_tag == "":
                self.add_finding(
                    findings=findings,
                    rule_id="CROSS-001",
                    severity=ValidationSeverity.MAJOR,
                    message="Equipment TAG is missing or empty",
                    field_path="equipment.equipment_tag",
                    extracted_value=equipment_tag,
                    threshold="Non-empty TAG required",
                    remediation="Verify equipment TAG is clearly visible in document",
                )

            # Validate equipment type is present
            eq_type = extraction.equipment.equipment_type.value
            if not eq_type:
                self.add_finding(
                    findings=findings,
                    rule_id="CROSS-002",
                    severity=ValidationSeverity.MINOR,
                    message="Equipment type not identified",
                    field_path="equipment.equipment_type",
                    extracted_value=eq_type,
                    threshold="Equipment type recommended",
                    remediation="Add equipment type for proper threshold selection",
                )

        # Validate measurement units are present (test-type specific)
        self._validate_measurement_units(findings, extraction)

        return self.create_result(findings, equipment_tag=equipment_tag)

    def _validate_measurement_units(self, findings: list[Finding], extraction) -> None:
        """Validate that measurements have units."""
        # Check grounding measurements
        if hasattr(extraction, 'measurements'):
            for i, m in enumerate(extraction.measurements):
                if hasattr(m, 'resistance_unit'):
                    if not m.resistance_unit:
                        self.add_finding(
                            findings=findings,
                            rule_id="CROSS-003",
                            severity=ValidationSeverity.MINOR,
                            message=f"Measurement {i} missing unit specification",
                            field_path=f"measurements[{i}].resistance_unit",
                            extracted_value=None,
                            threshold="Unit required (ohms, MΩ, etc.)",
                        )

        # Check thermography hotspots have temperature data
        if hasattr(extraction, 'hotspots'):
            for i, h in enumerate(extraction.hotspots):
                if h.max_temperature.value is None:
                    self.add_finding(
                        findings=findings,
                        rule_id="CROSS-004",
                        severity=ValidationSeverity.MAJOR,
                        message=f"Hotspot {i} missing max temperature",
                        field_path=f"hotspots[{i}].max_temperature",
                        extracted_value=None,
                        threshold="Temperature value required",
                    )
  </action>
  <verify>python3 -c "from app.core.validation.cross_field import CrossFieldValidator; print('✓ CrossFieldValidator imports')"</verify>
  <done>CrossFieldValidator validates field consistency</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] CalibrationValidator validates expiration
- [ ] Expired calibrations produce CRITICAL findings
- [ ] CrossFieldValidator validates TAG presence
- [ ] Measurement units validated
</verification>

<success_criteria>
- All tasks completed
- VALD-04, VALD-05, VALD-06 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/03-validation-engine/03-05-SUMMARY.md`
</output>
