---
phase: 03-validation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [app/core/validation/schemas.py, app/core/validation/config.py, app/core/validation/base.py, app/core/validation/__init__.py]
autonomous: true

must_haves:
  truths:
    - "Validation rules are defined in configuration, not hard-coded"
    - "Validation produces Finding objects with severity and evidence"
    - "Same extraction data always produces identical validation results"
  artifacts:
    - path: "app/core/validation/schemas.py"
      provides: "ValidationResult, Finding, ValidationSeverity schemas"
      exports: ["ValidationResult", "Finding", "ValidationSeverity", "ValidationRule"]
    - path: "app/core/validation/config.py"
      provides: "Externalized validation thresholds"
      exports: ["ValidationConfig", "get_validation_config"]
    - path: "app/core/validation/base.py"
      provides: "BaseValidator abstract class"
      exports: ["BaseValidator"]
  key_links:
    - from: "base.py"
      to: "schemas.py"
      via: "uses ValidationResult, Finding"
      pattern: "ValidationResult"
    - from: "base.py"
      to: "config.py"
      via: "reads ValidationConfig"
      pattern: "ValidationConfig"
---

<objective>
Create validation framework foundation with externalized configuration.

Purpose: Establish patterns for deterministic validation with externalized rules per VALD-07, VALD-08.
Output: BaseValidator, ValidationResult, Finding, and ValidationConfig structures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-extraction-pipeline/02-02-SUMMARY.md

Requirements this plan addresses:
- VALD-07: Validation produces identical results for identical inputs (deterministic)
- VALD-08: Validation rules are externalized in configuration (not hard-coded)

Existing patterns to follow:
- StrEnum from app/schemas/enums.py
- BaseExtractor pattern from app/core/extraction/base.py
- FieldConfidence pattern for tracking confidence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schemas</name>
  <files>app/core/validation/schemas.py</files>
  <action>
Create validation result and finding schemas.

app/core/validation/schemas.py:
- Import from pydantic: BaseModel, Field
- Import from enum: StrEnum

class ValidationSeverity(StrEnum):
    """Severity levels per project requirements."""
    CRITICAL = "critical"  # Immediate action required
    MAJOR = "major"        # Significant issue
    MINOR = "minor"        # Minor deviation
    INFO = "info"          # Informational

class Finding(BaseModel):
    """Single validation finding with evidence."""
    rule_id: str           # e.g., "GRND-001"
    severity: ValidationSeverity
    message: str           # Human-readable finding
    field_path: str        # e.g., "measurements[0].resistance_value"
    extracted_value: Any   # What was extracted
    threshold: Any         # What the threshold was
    standard_reference: str | None = None  # e.g., "IEEE 43 Table 1"
    remediation: str | None = None  # Suggested fix

class ValidationResult(BaseModel):
    """Complete validation result for an extraction."""
    test_type: str         # "grounding", "megger", "thermography"
    equipment_tag: str | None = None
    findings: list[Finding] = Field(default_factory=list)

    # Derived summary
    is_valid: bool = True  # No CRITICAL findings
    critical_count: int = 0
    major_count: int = 0
    minor_count: int = 0
    info_count: int = 0

    def model_post_init(self, __context) -> None:
        """Calculate summary counts."""
        for f in self.findings:
            if f.severity == ValidationSeverity.CRITICAL:
                self.critical_count += 1
                self.is_valid = False
            elif f.severity == ValidationSeverity.MAJOR:
                self.major_count += 1
            elif f.severity == ValidationSeverity.MINOR:
                self.minor_count += 1
            else:
                self.info_count += 1

class ValidationRule(BaseModel):
    """Rule definition for validation."""
    rule_id: str
    description: str
    severity: ValidationSeverity
    threshold: Any
    standard_reference: str | None = None
  </action>
  <verify>python3 -c "from app.core.validation.schemas import ValidationResult, Finding, ValidationSeverity"</verify>
  <done>Validation schemas defined with Finding and ValidationResult</done>
</task>

<task type="auto">
  <name>Task 2: Create validation configuration</name>
  <files>app/core/validation/config.py</files>
  <action>
Create externalized validation thresholds configuration.

app/core/validation/config.py:
- Import from pydantic import BaseModel, Field
- Import from pydantic_settings import BaseSettings (if needed)
- Import from functools import lru_cache
- Import EquipmentType from app.schemas.enums

class GroundingThresholds(BaseModel):
    """Grounding resistance thresholds per equipment type."""
    # NETA ATS Table 100.1 values (ohms)
    general_max: float = 5.0        # General equipment
    data_center_max: float = 1.0    # Data center (Microsoft CxPOR)
    panel_max: float = 5.0
    ups_max: float = 1.0
    ats_max: float = 5.0
    gen_max: float = 5.0
    xfmr_max: float = 5.0

class MeggerThresholds(BaseModel):
    """Insulation resistance thresholds per IEEE 43."""
    # IEEE 43 Table 3
    min_ir_megohms: float = 100.0   # Minimum 1-minute IR
    min_pi: float = 2.0             # Minimum Polarization Index
    min_ir_by_voltage: dict[int, float] = Field(default_factory=lambda: {
        500: 25.0,     # 500V test: min 25 M立
        1000: 100.0,   # 1000V test: min 100 M立
        2500: 500.0,   # 2500V test: min 500 M立
        5000: 1000.0,  # 5000V test: min 1000 M立
    })

class ThermographyThresholds(BaseModel):
    """Temperature delta thresholds per NETA MTS."""
    # NETA MTS delta-T classifications (Celsius)
    normal_max: float = 5.0
    attention_max: float = 15.0
    intermediate_max: float = 35.0
    serious_max: float = 70.0
    # Above serious_max = CRITICAL

class CalibrationConfig(BaseModel):
    """Calibration certificate validation settings."""
    max_days_expired: int = 0       # 0 = no expired allowed
    warn_days_before_expiry: int = 30

class ValidationConfig(BaseModel):
    """Complete validation configuration."""
    grounding: GroundingThresholds = Field(default_factory=GroundingThresholds)
    megger: MeggerThresholds = Field(default_factory=MeggerThresholds)
    thermography: ThermographyThresholds = Field(default_factory=ThermographyThresholds)
    calibration: CalibrationConfig = Field(default_factory=CalibrationConfig)

@lru_cache
def get_validation_config() -> ValidationConfig:
    """Get cached validation configuration.

    Uses lru_cache for determinism - same config every time.
    Future: Could load from YAML/JSON file.
    """
    return ValidationConfig()
  </action>
  <verify>python3 -c "from app.core.validation.config import get_validation_config; c = get_validation_config(); print(f'Grounding max: {c.grounding.general_max}')"</verify>
  <done>Validation configuration externalized with NETA/IEEE thresholds</done>
</task>

<task type="auto">
  <name>Task 3: Create base validator class</name>
  <files>app/core/validation/base.py, app/core/validation/__init__.py</files>
  <action>
Create abstract base validator following extraction patterns.

app/core/validation/base.py:
- Import ABC, abstractmethod from abc
- Import from app.core.validation.schemas import (Finding, ValidationResult, ValidationSeverity)
- Import from app.core.validation.config import get_validation_config, ValidationConfig
- Import from app.core.extraction.schemas import BaseExtractionResult

class BaseValidator(ABC):
    """Abstract base class for test-type validators.

    Validators are deterministic: same input always produces same output.
    No randomness, no timestamps in comparison, no external API calls.

    Subclasses implement validate() for specific test types.
    """

    def __init__(self, config: ValidationConfig | None = None):
        """Initialize with optional custom config for testing."""
        self.config = config or get_validation_config()

    @property
    @abstractmethod
    def test_type(self) -> str:
        """Return test type this validator handles."""
        pass

    @abstractmethod
    def validate(self, extraction: BaseExtractionResult) -> ValidationResult:
        """Validate extraction result and return findings.

        Must be deterministic: same extraction = same result.

        Args:
            extraction: The extraction result to validate.

        Returns:
            ValidationResult with findings list.
        """
        pass

    def add_finding(
        self,
        findings: list[Finding],
        rule_id: str,
        severity: ValidationSeverity,
        message: str,
        field_path: str,
        extracted_value: Any,
        threshold: Any,
        standard_reference: str | None = None,
        remediation: str | None = None,
    ) -> None:
        """Helper to add a finding to the list."""
        findings.append(Finding(
            rule_id=rule_id,
            severity=severity,
            message=message,
            field_path=field_path,
            extracted_value=extracted_value,
            threshold=threshold,
            standard_reference=standard_reference,
            remediation=remediation,
        ))

app/core/validation/__init__.py:
- Export all schemas
- Export base validator
- Export config functions
  </action>
  <verify>python3 -c "from app.core.validation import BaseValidator, ValidationResult, Finding, get_validation_config"</verify>
  <done>BaseValidator pattern established with deterministic design</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ValidationSeverity has CRITICAL, MAJOR, MINOR, INFO
- [ ] Finding has rule_id, severity, message, field_path, extracted_value, threshold
- [ ] ValidationResult calculates is_valid based on CRITICAL findings
- [ ] ValidationConfig has NETA/IEEE thresholds externalized
- [ ] BaseValidator is abstract with deterministic design
- [ ] All imports work correctly
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Patterns established for test-type validators
- Configuration is externalized (VALD-08)
- Design ensures determinism (VALD-07)
</success_criteria>

<output>
After completion, create `.planning/phases/03-validation-engine/03-01-SUMMARY.md`
</output>
