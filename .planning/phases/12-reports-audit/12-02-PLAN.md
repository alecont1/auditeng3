---
phase: 12-reports-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/types/analysis.ts
  - web/src/services/analysis.ts
  - web/src/hooks/useAuditTrail.ts
  - web/src/hooks/index.ts
  - web/src/components/analysis/AuditEventCard.tsx
  - web/src/components/analysis/AuditTimeline.tsx
  - web/src/components/analysis/index.ts
  - web/src/pages/AuditTrailPage.tsx
  - web/src/pages/index.ts
  - web/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate to audit trail page for an analysis"
    - "Audit events display in chronological timeline"
    - "User can expand event cards to see details"
    - "User can filter events by type"
    - "Loading and empty states handled correctly"
  artifacts:
    - path: "web/src/types/analysis.ts"
      provides: "AuditEvent and AuditTrailResponse types"
      contains: "AuditEvent"
    - path: "web/src/hooks/useAuditTrail.ts"
      provides: "Hook for fetching audit trail data"
      exports: ["useAuditTrail"]
    - path: "web/src/components/analysis/AuditTimeline.tsx"
      provides: "Timeline display with filter UI"
      min_lines: 50
    - path: "web/src/pages/AuditTrailPage.tsx"
      provides: "Page component with route params"
      min_lines: 30
  key_links:
    - from: "AuditTrailPage"
      to: "useAuditTrail hook"
      via: "data fetching"
      pattern: "useAuditTrail"
    - from: "useAuditTrail"
      to: "getAuditTrail service"
      via: "useQuery"
      pattern: "getAuditTrail"
    - from: "App.tsx routes"
      to: "AuditTrailPage"
      via: "React Router"
      pattern: "audit"
---

<objective>
Implement audit trail visualization for analysis compliance traceability.

Purpose: Engineers need to see the complete audit trail showing how each finding was generated, including extraction events, validation rules applied, model versions, and confidence scores for compliance documentation.

Output: AuditTrailPage with timeline view of events, expandable details, and filtering by event type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Backend endpoint already exists:
- GET /api/analyses/{id}/audit returns AuditTrailResponse
- Returns: { analysis_id, event_count, events: AuditEventResponse[] }
- Each event has: id, event_type, event_timestamp, details, model_version, prompt_version, confidence_score, rule_id
- Pagination via skip/limit query params

Event types from backend (common ones):
- extraction_started, extraction_completed
- validation_started, validation_completed
- validation_rule_applied
- finding_created
- verdict_computed
- human_review (when engineer approves/rejects)

@web/src/types/analysis.ts
@web/src/services/analysis.ts
@web/src/hooks/index.ts
@web/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add types and service function for audit trail</name>
  <files>web/src/types/analysis.ts, web/src/services/analysis.ts</files>
  <action>
    In types/analysis.ts, add:
    ```typescript
    export interface AuditEvent {
      id: string
      event_type: string
      event_timestamp: string
      details?: Record<string, unknown>
      model_version?: string
      prompt_version?: string
      confidence_score?: number
      rule_id?: string
    }

    export interface AuditTrailResponse {
      analysis_id: string
      event_count: number
      events: AuditEvent[]
    }
    ```

    In services/analysis.ts, add:
    ```typescript
    export async function getAuditTrail(
      analysisId: string,
      params?: { skip?: number; limit?: number }
    ): Promise<AuditTrailResponse> {
      const response = await api.get<AuditTrailResponse>(
        `/analyses/${analysisId}/audit`,
        { params }
      )
      return response.data
    }
    ```

    Update type imports as needed.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>AuditEvent and AuditTrailResponse types exported, getAuditTrail service function works</done>
</task>

<task type="auto">
  <name>Task 2: Create useAuditTrail hook</name>
  <files>web/src/hooks/useAuditTrail.ts, web/src/hooks/index.ts</files>
  <action>
    Create useAuditTrail hook using TanStack Query:

    ```typescript
    import { useQuery } from '@tanstack/react-query'
    import { getAuditTrail } from '@/services/analysis'

    export function useAuditTrail(analysisId: string | undefined) {
      return useQuery({
        queryKey: ['audit-trail', analysisId],
        queryFn: () => getAuditTrail(analysisId!),
        enabled: !!analysisId,
        staleTime: 30000, // 30 seconds - audit trails don't change often
      })
    }
    ```

    Export from hooks/index.ts
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>useAuditTrail hook exported and follows TanStack Query patterns</done>
</task>

<task type="auto">
  <name>Task 3: Create AuditEventCard component</name>
  <files>web/src/components/analysis/AuditEventCard.tsx, web/src/components/analysis/index.ts</files>
  <action>
    Create AuditEventCard as expandable card showing event details:

    Props:
    - event: AuditEvent

    Collapsed state shows:
    - Event type badge (color-coded by category: extraction=blue, validation=green, finding=amber, review=purple)
    - Timestamp (formatted: "Jan 17, 2026 14:32:15")
    - Brief description derived from event_type (e.g., "Extraction Started" for "extraction_started")

    Expanded state (use Collapsible from shadcn or simple useState toggle):
    - Details JSON (if exists) formatted nicely or as key-value pairs
    - Model version (if exists)
    - Prompt version (if exists)
    - Confidence score (if exists) - show as percentage with color coding
    - Rule ID (if exists)

    Event type color mapping:
    - extraction_*: blue-500
    - validation_*: green-500
    - finding_*: amber-500
    - verdict_*: purple-500
    - human_*: indigo-500
    - default: gray-500

    Use Card component from shadcn, ChevronDown/ChevronUp for expand indicator.
    Format timestamp with date-fns or Intl.DateTimeFormat.

    Export from index.ts
  </action>
  <verify>npm run build succeeds</verify>
  <done>AuditEventCard renders event with expandable details section</done>
</task>

<task type="auto">
  <name>Task 4: Create AuditTimeline component with filters</name>
  <files>web/src/components/analysis/AuditTimeline.tsx, web/src/components/analysis/index.ts</files>
  <action>
    Create AuditTimeline component that displays events in a vertical timeline:

    Props:
    - events: AuditEvent[]
    - isLoading?: boolean

    Features:
    1. Filter dropdown at top:
       - "All Events" (default)
       - "Extraction" (event_type.startsWith('extraction'))
       - "Validation" (event_type.startsWith('validation'))
       - "Findings" (event_type.startsWith('finding'))
       - "Review" (event_type includes 'review' or 'verdict')

    2. Event count badge showing "{filtered}/{total} events"

    3. Timeline display:
       - Vertical line on left side (border-left-2 border-gray-200)
       - Each AuditEventCard positioned with timeline dot
       - Timeline dot colors match event type colors
       - Oldest first (chronological - already sorted by backend)

    4. Loading state: Skeleton cards
    5. Empty state: "No audit events found" message

    Use useState for filter selection.
    Filter events client-side (simple with ~100 events max).

    Export from index.ts
  </action>
  <verify>npm run build succeeds</verify>
  <done>AuditTimeline shows filtered timeline with event cards</done>
</task>

<task type="auto">
  <name>Task 5: Create AuditTrailPage and wire to routes</name>
  <files>web/src/pages/AuditTrailPage.tsx, web/src/pages/index.ts, web/src/App.tsx</files>
  <action>
    Create AuditTrailPage:

    1. Get analysisId from URL params: useParams<{ analysisId: string }>()
    2. Use useAuditTrail(analysisId) to fetch data
    3. Layout:
       - Header: "Audit Trail" title + Back link to analysis details
       - Subheader: Analysis ID (truncated) + event count
       - Main content: AuditTimeline component

    Handle states:
    - Loading: Spinner or skeleton
    - Error: Error message with retry button
    - Success: AuditTimeline with events

    In pages/index.ts:
    - Export AuditTrailPage

    In App.tsx:
    - Add route: /analyses/:analysisId/audit â†’ AuditTrailPage
    - Must be within ProtectedRoute wrapper
    - Place AFTER the /analyses/:analysisId route to avoid conflict

    Also add link to audit trail from AnalysisDetailsPage:
    - Add "View Audit Trail" link/button near other actions
    - Links to /analyses/{analysisId}/audit
  </action>
  <verify>npm run build succeeds</verify>
  <done>AuditTrailPage accessible via /analyses/:analysisId/audit route</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] AuditEvent and AuditTrailResponse types match backend schema
- [ ] useAuditTrail hook fetches data correctly
- [ ] AuditEventCard expands/collapses to show details
- [ ] AuditTimeline filters events by type
- [ ] Route /analyses/:analysisId/audit works
- [ ] Link from AnalysisDetailsPage navigates to audit trail
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Timeline displays events chronologically
- Event cards show all relevant metadata when expanded
- Filter dropdown works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/12-reports-audit/12-02-SUMMARY.md`
</output>
