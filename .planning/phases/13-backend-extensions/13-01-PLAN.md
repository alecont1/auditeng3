---
phase: 13-backend-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/schemas.py
  - app/api/analyses.py
autonomous: true

must_haves:
  truths:
    - "GET /api/analyses returns paginated list of user's analyses"
    - "List can be filtered by status (queued, processing, completed, failed)"
    - "List can be filtered by date range (date_from, date_to)"
    - "List can be sorted by created_at or compliance_score"
    - "Pagination metadata includes total count, page, per_page"
  artifacts:
    - path: "app/api/schemas.py"
      provides: "AnalysisListItem, AnalysisListResponse, PaginationMeta schemas"
      contains: "class AnalysisListResponse"
    - path: "app/api/analyses.py"
      provides: "GET /api/analyses endpoint with pagination"
      contains: "async def list_analyses"
  key_links:
    - from: "list_analyses endpoint"
      to: "Task.user_id filter"
      via: "SQLAlchemy join"
      pattern: "Task\\.user_id == current_user\\.id"
---

<objective>
Implement GET /api/analyses endpoint for listing user's analyses with pagination, filtering, and sorting.

Purpose: Frontend dashboard needs to display all analyses belonging to the current user with ability to filter by status/date and sort by various fields.
Output: Working paginated list endpoint that returns AnalysisListResponse.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/milestones/v2.0-ROADMAP.md

# Existing code to extend:
@app/api/schemas.py
@app/api/analyses.py
@app/db/models/task.py
@app/db/models/analysis.py
@app/schemas/enums.py
@app/core/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list schemas to app/api/schemas.py</name>
  <files>app/api/schemas.py</files>
  <action>
Add the following Pydantic schemas after existing schemas:

1. `PaginationMeta` - pagination metadata:
   - total: int (total count of items)
   - page: int (current page, 1-indexed)
   - per_page: int (items per page)
   - total_pages: int (computed from total and per_page)

2. `AnalysisListItem` - summary for list view:
   - id: UUID
   - equipment_type: str
   - test_type: str
   - equipment_tag: str | None
   - verdict: str | None
   - compliance_score: float | None
   - status: str (from linked task)
   - created_at: datetime
   - original_filename: str (from linked task)

3. `AnalysisListResponse` - paginated response:
   - items: list[AnalysisListItem]
   - pagination: PaginationMeta

Follow existing patterns in the file (BaseModel, Field with descriptions, model_config).
  </action>
  <verify>python -c "from app.api.schemas import AnalysisListResponse, AnalysisListItem, PaginationMeta; print('OK')"</verify>
  <done>Three new schemas importable and type-correct</done>
</task>

<task type="auto">
  <name>Task 2: Implement GET /api/analyses endpoint</name>
  <files>app/api/analyses.py</files>
  <action>
Add a new endpoint to the existing router:

```python
@router.get(
    "",
    response_model=AnalysisListResponse,
    summary="List user's analyses",
    description="Get paginated list of analyses belonging to current user with filtering and sorting.",
)
async def list_analyses(
    db: DbSession,
    current_user: CurrentUser,
    status: str | None = Query(None, description="Filter by task status"),
    date_from: datetime | None = Query(None, description="Filter by created_at >= date_from"),
    date_to: datetime | None = Query(None, description="Filter by created_at <= date_to"),
    sort_by: str = Query("created_at", description="Sort field: created_at or compliance_score"),
    sort_order: str = Query("desc", description="Sort order: asc or desc"),
    page: int = Query(1, ge=1, description="Page number (1-indexed)"),
    per_page: int = Query(10, ge=1, le=100, description="Items per page"),
) -> AnalysisListResponse:
```

Implementation details:
1. Build base query joining Analysis with Task
2. Filter by `Task.user_id == current_user.id` (REQUIRED - security)
3. Apply optional status filter on Task.status
4. Apply optional date_from/date_to filters on Analysis.created_at
5. Apply sorting (validate sort_by is "created_at" or "compliance_score", default desc)
6. Count total before pagination
7. Apply offset/limit for pagination
8. Build response with items and pagination metadata

Import Query from fastapi. Import datetime from datetime module.
Add AnalysisListResponse, AnalysisListItem, PaginationMeta to imports from .schemas.
  </action>
  <verify>
Start the server and test:
curl -X GET "http://localhost:8000/api/analyses?page=1&per_page=5" -H "Authorization: Bearer $TOKEN"
Should return 200 with items array and pagination object.
  </verify>
  <done>
- GET /api/analyses returns paginated results
- Filtering by status, date_from, date_to works
- Sorting by created_at and compliance_score works
- Only returns analyses owned by current user
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from app.api.schemas import AnalysisListResponse"` succeeds
- [ ] `python -c "from app.api.analyses import list_analyses"` succeeds
- [ ] Server starts without errors: `uvicorn app.main:app --reload`
- [ ] Endpoint documented in OpenAPI: visit /docs and check /api/analyses
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript/Python errors
- Endpoint returns proper pagination structure
- Security: only user's own analyses returned
</success_criteria>

<output>
After completion, create `.planning/phases/13-backend-extensions/13-01-SUMMARY.md`
</output>
