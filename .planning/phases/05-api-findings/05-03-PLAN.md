---
phase: 05-api-findings
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - app/api/analyses.py
  - app/services/extraction.py
  - app/worker/extraction.py
  - app/api/__init__.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "Authenticated user can submit document for analysis"
    - "Authenticated user can poll analysis status"
    - "Authenticated user can retrieve complete results with findings"
    - "Results include verdict, compliance score, and confidence score"
    - "Each finding has evidence and remediation"
  artifacts:
    - path: "app/api/analyses.py"
      provides: "Analysis submission and results API"
      exports: ["router"]
    - path: "app/services/extraction.py"
      provides: "Updated extraction service with finding generation"
      contains: "FindingService"
  key_links:
    - from: "app/api/analyses.py"
      to: "app/core/auth.py"
      via: "get_current_user dependency"
      pattern: "Depends.*get_current_user"
    - from: "app/services/extraction.py"
      to: "app/services/finding.py"
      via: "Finding generation after validation"
      pattern: "FindingService|generate_findings"
    - from: "app/api/analyses.py"
      to: "app/db/models/analysis.py"
      via: "Analysis with findings query"
      pattern: "selectinload.*findings"
---

<objective>
Create unified analysis API with authentication and complete result retrieval.

Purpose: Provide REST API for document submission, status polling, and results retrieval per API-01, API-02, API-03 requirements.
Output: Protected /api/analyses endpoints with finding-enriched responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auth provides get_current_user dependency (from 05-01)
@app/core/auth.py

# Finding and verdict services (from 05-02)
@app/services/finding.py
@app/services/verdict.py

# Existing upload and task APIs to consolidate
@app/api/upload.py
@app/api/tasks.py

# Extraction service to update
@app/services/extraction.py
@app/worker/extraction.py

# Models for queries
@app/db/models/analysis.py
@app/db/models/finding.py
@app/db/models/task.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update extraction service to generate findings</name>
  <files>app/services/extraction.py, app/worker/extraction.py</files>
  <action>
    Update app/services/extraction.py process_document function:

    1. After validation, generate findings:
       - Import FindingService from app.services.finding
       - Import VerdictService from app.services.verdict
       - After orchestrator.validate(extraction), call:
         - findings = FindingService.generate_findings_from_validation(validation_result, analysis.id)
         - verdict, compliance_score, confidence_score = VerdictService.compute_analysis_verdict(validation_result, extraction)

    2. Update Analysis model with scores:
       - Set analysis.verdict = verdict.value
       - Set analysis.compliance_score = compliance_score
       - Set analysis.confidence_score = confidence_score

    3. Persist findings to database:
       - FindingService.persist_findings(db, findings)

    Update app/worker/extraction.py:
       - Ensure findings are persisted within the same transaction
       - Commit after all findings saved

    The extraction pipeline should now produce complete Analysis with:
       - extraction_result (JSON)
       - validation_result (JSON)
       - findings (relationship to Finding records)
       - verdict, compliance_score, confidence_score
  </action>
  <verify>python -c "from app.services.extraction import process_document; print('OK')"</verify>
  <done>Extraction pipeline generates findings and verdicts</done>
</task>

<task type="auto">
  <name>Task 2: Create analyses API with authentication</name>
  <files>app/api/analyses.py, app/schemas/analysis.py</files>
  <action>
    Create app/api/analyses.py with APIRouter(prefix="/api/analyses", tags=["analyses"]):

    1. POST /api/analyses/submit - Submit document (protected):
       - Depends: get_current_user for authentication
       - Accept: UploadFile (reuse existing upload logic)
       - Create Task owned by current user
       - Enqueue extraction job
       - Return: {analysis_id, task_id, status: "queued"}

    2. GET /api/analyses/{analysis_id}/status - Poll status (protected):
       - Depends: get_current_user
       - Verify user owns the analysis (via task.user_id)
       - Return: {analysis_id, status, progress_message}

    3. GET /api/analyses/{analysis_id} - Get full results (protected):
       - Depends: get_current_user
       - Verify user owns the analysis
       - Return 202 if still processing
       - Return complete AnalysisResponse with:
         - Basic info (equipment_type, test_type, equipment_tag)
         - Scores (compliance_score, confidence_score)
         - Verdict
         - Findings list with evidence and remediation
         - extraction_result (raw extracted data)

    Update app/schemas/analysis.py:
       - AnalysisSubmitResponse: analysis_id, task_id, status
       - AnalysisStatusResponse: analysis_id, status, message
       - FindingDetail: rule_id, severity, message, field_path, evidence, remediation
       - AnalysisResponse: id, equipment_type, test_type, equipment_tag, verdict, compliance_score, confidence_score, findings: list[FindingDetail], created_at

    User ownership check: analysis.task.user_id == current_user.id
  </action>
  <verify>python -c "from app.api.analyses import router; print('OK')"</verify>
  <done>Analyses API provides protected endpoints for submit/status/results</done>
</task>

<task type="auto">
  <name>Task 3: Register analyses router and add integration tests</name>
  <files>app/main.py, app/tests/api/__init__.py, app/tests/api/test_analyses.py</files>
  <action>
    Update app/main.py:
       - Import analyses router: from app.api.analyses import router as analyses_router
       - Include router: app.include_router(analyses_router)

    Create app/tests/api/__init__.py (empty package file)

    Create app/tests/api/test_analyses.py with integration tests:
       - Use TestClient from fastapi.testclient
       - Create test user and get auth token

    Test cases:
       - test_submit_requires_auth: 401 without token
       - test_submit_with_auth: Returns analysis_id with valid token
       - test_status_requires_auth: 401 without token
       - test_status_wrong_user: 403 when accessing other user's analysis
       - test_get_results_requires_auth: 401 without token
       - test_get_results_complete: Returns full analysis with findings

    Use pytest fixtures for:
       - test_client with app
       - auth_token for authenticated requests
       - sample_analysis in database
  </action>
  <verify>pytest app/tests/api/test_analyses.py -v</verify>
  <done>Analyses API registered and integration tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Extraction pipeline generates findings in database
- [ ] POST /api/analyses/submit requires authentication
- [ ] GET /api/analyses/{id}/status requires authentication and ownership
- [ ] GET /api/analyses/{id} returns complete results with findings
- [ ] Each finding has evidence (extracted_value, threshold, standard_reference)
- [ ] Response includes verdict, compliance_score, confidence_score
- [ ] OpenAPI docs show new analyses endpoints
- [ ] Integration tests pass
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Complete analysis flow: submit → poll → get results with findings
- User ownership enforced on all endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-findings/05-03-SUMMARY.md`
</output>
