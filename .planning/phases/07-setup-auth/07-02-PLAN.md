---
phase: 07-setup-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/lib/api.ts
  - web/src/types/api.ts
  - web/src/types/auth.ts
  - web/src/contexts/AuthContext.tsx
  - web/src/hooks/useAuth.ts
autonomous: true
must_haves:
  truths:
    - "API client can make authenticated requests with token"
    - "Auth context provides login/logout functions"
    - "Token persists in localStorage across page refresh"
    - "401 responses trigger automatic logout"
  artifacts:
    - path: "web/src/lib/api.ts"
      provides: "Axios instance with auth interceptors"
      contains: "axios.create"
    - path: "web/src/types/auth.ts"
      provides: "TypeScript types for auth flow"
      contains: "TokenResponse"
    - path: "web/src/contexts/AuthContext.tsx"
      provides: "React context for auth state"
      contains: "createContext"
    - path: "web/src/hooks/useAuth.ts"
      provides: "Custom hook for auth operations"
      contains: "useAuth"
  key_links:
    - from: "web/src/lib/api.ts"
      to: "localStorage"
      via: "token injection interceptor"
      pattern: "localStorage.getItem"
    - from: "web/src/contexts/AuthContext.tsx"
      to: "web/src/lib/api.ts"
      via: "login function calls api"
      pattern: "api.post.*login"
---

<objective>
Create the API client and authentication context for the frontend.

Purpose: Enable secure communication with the backend and manage auth state across the app.
Output: Axios client with auth interceptors, AuthContext provider, and useAuth hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

Backend auth endpoints (from app/api/auth.py):
- POST /api/auth/login - OAuth2PasswordRequestForm (username=email, password) -> {access_token, token_type}
- POST /api/auth/register - {email, password} -> {access_token, token_type}
- POST /api/auth/refresh - requires auth -> {access_token, token_type}
- GET /api/auth/me - requires auth -> {id, email, is_active, created_at}

Token format: Bearer JWT in Authorization header
Token expiry: Configured via ACCESS_TOKEN_EXPIRE_MINUTES (default likely 30-60 min)

NOTE: This plan can run in PARALLEL with 07-01 because it only creates files in src/lib, src/types, src/contexts, src/hooks - no overlap with 07-01's files.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API types</name>
  <files>web/src/types/api.ts, web/src/types/auth.ts</files>
  <action>
    Create TypeScript types matching the backend API contracts.

    1. Create web/src/types/api.ts:
       ```typescript
       /**
        * Standard API error response from backend
        */
       export interface ApiError {
         detail: string
         error_code?: string
       }

       /**
        * Paginated response wrapper
        */
       export interface PaginatedResponse<T> {
         items: T[]
         total: number
         page: number
         per_page: number
         pages: number
       }
       ```

    2. Create web/src/types/auth.ts:
       ```typescript
       /**
        * Login request payload
        * Note: Backend uses OAuth2PasswordRequestForm which expects 'username' field
        */
       export interface LoginRequest {
         email: string
         password: string
       }

       /**
        * Registration request payload
        */
       export interface RegisterRequest {
         email: string
         password: string
       }

       /**
        * Token response from login/register/refresh
        */
       export interface TokenResponse {
         access_token: string
         token_type: string
       }

       /**
        * Current user information from /api/auth/me
        */
       export interface User {
         id: string
         email: string
         is_active: boolean
         created_at: string
       }

       /**
        * Auth state for context
        */
       export interface AuthState {
         user: User | null
         token: string | null
         isAuthenticated: boolean
         isLoading: boolean
       }
       ```

    3. Create web/src/types/index.ts to re-export:
       ```typescript
       export * from './api'
       export * from './auth'
       ```
  </action>
  <verify>TypeScript compiles without errors: cd web && npx tsc --noEmit</verify>
  <done>API and auth types defined matching backend contracts</done>
</task>

<task type="auto">
  <name>Task 2: Create Axios API client with interceptors</name>
  <files>web/src/lib/api.ts</files>
  <action>
    Create Axios instance with auth token injection and error handling.

    Install axios: `cd web && npm install axios`

    Create web/src/lib/api.ts:
    ```typescript
    import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios'
    import type { ApiError } from '@/types'

    const TOKEN_KEY = 'auditeng_token'

    /**
     * Get stored auth token
     */
    export function getToken(): string | null {
      return localStorage.getItem(TOKEN_KEY)
    }

    /**
     * Store auth token
     */
    export function setToken(token: string): void {
      localStorage.setItem(TOKEN_KEY, token)
    }

    /**
     * Remove auth token
     */
    export function removeToken(): void {
      localStorage.removeItem(TOKEN_KEY)
    }

    /**
     * Check if token exists
     */
    export function hasToken(): boolean {
      return !!getToken()
    }

    /**
     * Axios instance configured for AuditEng API
     */
    export const api = axios.create({
      baseURL: '/api',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    /**
     * Request interceptor: inject auth token
     */
    api.interceptors.request.use(
      (config: InternalAxiosRequestConfig) => {
        const token = getToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    /**
     * Response interceptor: handle errors
     */
    api.interceptors.response.use(
      (response) => response,
      (error: AxiosError<ApiError>) => {
        // Handle 401 Unauthorized - clear token and redirect to login
        if (error.response?.status === 401) {
          removeToken()
          // Dispatch custom event for auth context to handle
          window.dispatchEvent(new CustomEvent('auth:logout'))
        }

        // Re-throw with better error message
        const message = error.response?.data?.detail || error.message || 'An error occurred'
        return Promise.reject(new Error(message))
      }
    )

    export default api
    ```

    Key design decisions:
    - Use localStorage for token (simple, works for SPA)
    - Dispatch custom event on 401 for auth context to catch
    - BaseURL is /api (Vite proxy handles routing to backend)
    - Content-Type: application/json by default
  </action>
  <verify>TypeScript compiles: cd web && npx tsc --noEmit</verify>
  <done>Axios client with token injection and 401 handling</done>
</task>

<task type="auto">
  <name>Task 3: Create AuthContext and useAuth hook</name>
  <files>web/src/contexts/AuthContext.tsx, web/src/hooks/useAuth.ts</files>
  <action>
    Create React context for auth state and useAuth hook for components.

    1. Create web/src/contexts/AuthContext.tsx:
       ```typescript
       import { createContext, useCallback, useEffect, useState, type ReactNode } from 'react'
       import api, { getToken, setToken, removeToken, hasToken } from '@/lib/api'
       import type { User, LoginRequest, RegisterRequest, AuthState } from '@/types'

       interface AuthContextValue extends AuthState {
         login: (credentials: LoginRequest) => Promise<void>
         register: (data: RegisterRequest) => Promise<void>
         logout: () => void
         refreshUser: () => Promise<void>
       }

       export const AuthContext = createContext<AuthContextValue | null>(null)

       interface AuthProviderProps {
         children: ReactNode
       }

       export function AuthProvider({ children }: AuthProviderProps) {
         const [user, setUser] = useState<User | null>(null)
         const [token, setTokenState] = useState<string | null>(getToken())
         const [isLoading, setIsLoading] = useState(true)

         const isAuthenticated = !!token && !!user

         /**
          * Fetch current user from /api/auth/me
          */
         const refreshUser = useCallback(async () => {
           if (!hasToken()) {
             setUser(null)
             setIsLoading(false)
             return
           }

           try {
             const response = await api.get<User>('/auth/me')
             setUser(response.data)
           } catch {
             // Token invalid or expired
             removeToken()
             setTokenState(null)
             setUser(null)
           } finally {
             setIsLoading(false)
           }
         }, [])

         /**
          * Login with email and password
          */
         const login = useCallback(async (credentials: LoginRequest) => {
           // Backend expects OAuth2PasswordRequestForm (form data, not JSON)
           const formData = new URLSearchParams()
           formData.append('username', credentials.email)
           formData.append('password', credentials.password)

           const response = await api.post<{ access_token: string; token_type: string }>(
             '/auth/login',
             formData,
             {
               headers: {
                 'Content-Type': 'application/x-www-form-urlencoded',
               },
             }
           )

           const { access_token } = response.data
           setToken(access_token)
           setTokenState(access_token)

           // Fetch user info after login
           await refreshUser()
         }, [refreshUser])

         /**
          * Register new account
          */
         const register = useCallback(async (data: RegisterRequest) => {
           const response = await api.post<{ access_token: string; token_type: string }>(
             '/auth/register',
             data
           )

           const { access_token } = response.data
           setToken(access_token)
           setTokenState(access_token)

           // Fetch user info after registration
           await refreshUser()
         }, [refreshUser])

         /**
          * Logout - clear token and user
          */
         const logout = useCallback(() => {
           removeToken()
           setTokenState(null)
           setUser(null)
         }, [])

         // On mount, try to restore session
         useEffect(() => {
           refreshUser()
         }, [refreshUser])

         // Listen for 401 events from API interceptor
         useEffect(() => {
           const handleLogout = () => logout()
           window.addEventListener('auth:logout', handleLogout)
           return () => window.removeEventListener('auth:logout', handleLogout)
         }, [logout])

         const value: AuthContextValue = {
           user,
           token,
           isAuthenticated,
           isLoading,
           login,
           register,
           logout,
           refreshUser,
         }

         return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
       }
       ```

    2. Create web/src/hooks/useAuth.ts:
       ```typescript
       import { useContext } from 'react'
       import { AuthContext } from '@/contexts/AuthContext'

       /**
        * Hook to access auth context
        * @throws Error if used outside AuthProvider
        */
       export function useAuth() {
         const context = useContext(AuthContext)

         if (!context) {
           throw new Error('useAuth must be used within an AuthProvider')
         }

         return context
       }
       ```

    3. Create web/src/hooks/index.ts:
       ```typescript
       export { useAuth } from './useAuth'
       ```

    4. Create web/src/contexts/index.ts:
       ```typescript
       export { AuthContext, AuthProvider } from './AuthContext'
       ```
  </action>
  <verify>TypeScript compiles: cd web && npx tsc --noEmit</verify>
  <done>AuthContext with login/logout/register and session restoration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd web && npx tsc --noEmit` passes (no TypeScript errors)
- [ ] API types match backend schemas (TokenResponse, User, etc.)
- [ ] Token storage functions work (get/set/remove)
- [ ] AuthContext provides login, logout, register functions
- [ ] 401 interceptor dispatches logout event
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Auth context ready to be wired into App
</success_criteria>

<output>
After completion, create `.planning/phases/07-setup-auth/07-02-SUMMARY.md`
</output>
