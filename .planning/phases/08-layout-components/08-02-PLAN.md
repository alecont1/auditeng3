---
phase: 08-layout-components
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/ui/spinner.tsx
  - web/src/components/ui/empty-state.tsx
  - web/src/components/ErrorBoundary.tsx
  - web/src/components/ui/sonner.tsx
  - web/src/main.tsx
  - web/package.json
autonomous: true

must_haves:
  truths:
    - "Loading states display animated spinner"
    - "Empty lists show informative placeholder with icon"
    - "Success/error actions trigger toast notifications"
    - "Runtime component errors show fallback UI instead of crash"
  artifacts:
    - path: "web/src/components/ui/spinner.tsx"
      provides: "Loading spinner with animation"
      min_lines: 10
    - path: "web/src/components/ui/empty-state.tsx"
      provides: "Empty state placeholder component"
      min_lines: 20
    - path: "web/src/components/ErrorBoundary.tsx"
      provides: "Error boundary with fallback UI"
      contains: "componentDidCatch"
    - path: "web/src/components/ui/sonner.tsx"
      provides: "Toast notification component"
      contains: "Toaster"
  key_links:
    - from: "web/src/main.tsx"
      to: "web/src/components/ui/sonner.tsx"
      via: "Toaster mounted at app root"
      pattern: "<Toaster"
    - from: "web/src/components/ErrorBoundary.tsx"
      to: "fallback UI"
      via: "Renders fallback on error"
      pattern: "this\\.state\\.hasError"
---

<objective>
Create common UI components for loading states, empty states, toasts, and error handling.

Purpose: Provide consistent feedback mechanisms across the application for async operations, empty data, and errors.
Output: Reusable components that other phases will use throughout the app.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v2.0-ROADMAP.md
@.planning/STATE.md

# Existing files to understand:
@web/src/main.tsx
@web/src/lib/utils.ts
@web/src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Spinner component</name>
  <files>web/src/components/ui/spinner.tsx</files>
  <action>
    Create a reusable loading spinner component:

    ```tsx
    import { cn } from '@/lib/utils'
    import { Loader2 } from 'lucide-react'

    interface SpinnerProps {
      size?: 'sm' | 'md' | 'lg'
      className?: string
    }

    const sizeClasses = {
      sm: 'h-4 w-4',
      md: 'h-6 w-6',
      lg: 'h-8 w-8',
    }

    export function Spinner({ size = 'md', className }: SpinnerProps) {
      return (
        <Loader2
          className={cn('animate-spin text-muted-foreground', sizeClasses[size], className)}
        />
      )
    }
    ```

    Uses Lucide's Loader2 icon with Tailwind animate-spin.
    Three sizes: sm (16px), md (24px), lg (32px).
    Accepts className for customization.
  </action>
  <verify>Import Spinner in a test file and verify it renders without errors</verify>
  <done>Spinner component created with size variants and animation</done>
</task>

<task type="auto">
  <name>Task 2: Create EmptyState component</name>
  <files>web/src/components/ui/empty-state.tsx</files>
  <action>
    Create a flexible empty state component:

    ```tsx
    import { cn } from '@/lib/utils'
    import { LucideIcon, Inbox } from 'lucide-react'

    interface EmptyStateProps {
      icon?: LucideIcon
      title: string
      description?: string
      action?: React.ReactNode
      className?: string
    }

    export function EmptyState({
      icon: Icon = Inbox,
      title,
      description,
      action,
      className,
    }: EmptyStateProps) {
      return (
        <div className={cn('flex flex-col items-center justify-center py-12 text-center', className)}>
          <div className="rounded-full bg-muted p-4 mb-4">
            <Icon className="h-8 w-8 text-muted-foreground" />
          </div>
          <h3 className="text-lg font-semibold mb-1">{title}</h3>
          {description && (
            <p className="text-sm text-muted-foreground max-w-sm mb-4">{description}</p>
          )}
          {action && <div>{action}</div>}
        </div>
      )
    }
    ```

    Props:
    - icon: Any Lucide icon (defaults to Inbox)
    - title: Required heading
    - description: Optional subtext
    - action: Optional React node (e.g., a button)
    - className: For customization
  </action>
  <verify>tsc --noEmit passes</verify>
  <done>EmptyState component created with icon, title, description, and action slot</done>
</task>

<task type="auto">
  <name>Task 3: Add sonner toast and configure Toaster</name>
  <files>web/src/components/ui/sonner.tsx, web/src/main.tsx, web/package.json</files>
  <action>
    Install sonner (lightweight toast library that works well with shadcn):
    ```bash
    cd web && npm install sonner
    ```

    Create sonner wrapper component for consistent styling:

    **web/src/components/ui/sonner.tsx:**
    ```tsx
    import { Toaster as Sonner } from 'sonner'

    type ToasterProps = React.ComponentProps<typeof Sonner>

    export function Toaster({ ...props }: ToasterProps) {
      return (
        <Sonner
          theme="light"
          className="toaster group"
          toastOptions={{
            classNames: {
              toast:
                'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
              description: 'group-[.toast]:text-muted-foreground',
              actionButton:
                'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
              cancelButton:
                'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
            },
          }}
          {...props}
        />
      )
    }
    ```

    **web/src/main.tsx:**
    Add Toaster component after BrowserRouter but inside the app tree:
    ```tsx
    import { Toaster } from '@/components/ui/sonner'

    // Inside render, add <Toaster /> after </BrowserRouter> but before closing wrapper
    ```

    Usage in components will be: `import { toast } from 'sonner'` then `toast.success('Saved!')` or `toast.error('Failed')`
  </action>
  <verify>npm run build succeeds, Toaster renders without errors</verify>
  <done>Toast notifications configured with sonner, Toaster mounted in app</done>
</task>

<task type="auto">
  <name>Task 4: Create ErrorBoundary component</name>
  <files>web/src/components/ErrorBoundary.tsx</files>
  <action>
    Create a class-based error boundary (required for componentDidCatch):

    ```tsx
    import { Component, ErrorInfo, ReactNode } from 'react'
    import { Button } from '@/components/ui/button'
    import { AlertTriangle } from 'lucide-react'

    interface Props {
      children: ReactNode
      fallback?: ReactNode
    }

    interface State {
      hasError: boolean
      error?: Error
    }

    export class ErrorBoundary extends Component<Props, State> {
      public state: State = {
        hasError: false,
      }

      public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error }
      }

      public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo)
      }

      private handleReset = () => {
        this.setState({ hasError: false, error: undefined })
      }

      public render() {
        if (this.state.hasError) {
          if (this.props.fallback) {
            return this.props.fallback
          }

          return (
            <div className="flex flex-col items-center justify-center min-h-[400px] p-8 text-center">
              <div className="rounded-full bg-destructive/10 p-4 mb-4">
                <AlertTriangle className="h-8 w-8 text-destructive" />
              </div>
              <h2 className="text-xl font-semibold mb-2">Something went wrong</h2>
              <p className="text-sm text-muted-foreground mb-4 max-w-md">
                An unexpected error occurred. Please try again or refresh the page.
              </p>
              <div className="flex gap-2">
                <Button variant="outline" onClick={this.handleReset}>
                  Try Again
                </Button>
                <Button onClick={() => window.location.reload()}>
                  Refresh Page
                </Button>
              </div>
              {process.env.NODE_ENV === 'development' && this.state.error && (
                <pre className="mt-4 p-4 bg-muted rounded text-xs text-left overflow-auto max-w-full">
                  {this.state.error.message}
                </pre>
              )}
            </div>
          )
        }

        return this.props.children
      }
    }
    ```

    Features:
    - Catches runtime errors in child component tree
    - Shows friendly error UI with retry options
    - In development, shows error message for debugging
    - Supports custom fallback prop
    - Try Again resets error state, Refresh reloads page
  </action>
  <verify>tsc --noEmit passes, ErrorBoundary can be imported</verify>
  <done>ErrorBoundary catches errors and displays fallback UI</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd web && npm run build` succeeds without errors
- [ ] `cd web && npx tsc --noEmit` shows no TypeScript errors
- [ ] Spinner component renders with animation
- [ ] EmptyState component renders with icon, title, and description
- [ ] Toaster appears in DOM (inspect element shows sonner container)
- [ ] ErrorBoundary compiles and can wrap components
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Components follow shadcn/ui design patterns
- No TypeScript or build errors
- Components are reusable across future phases
</success_criteria>

<output>
After completion, create `.planning/phases/08-layout-components/08-02-SUMMARY.md`
</output>
