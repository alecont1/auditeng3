---
phase: 01-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [app/worker/__init__.py, app/worker/broker.py, app/worker/middleware.py, app/worker/tasks.py, app/worker/status.py]
autonomous: true

must_haves:
  truths:
    - "Dramatiq broker connects to Redis"
    - "Jobs can be enqueued with status tracking"
    - "Failed jobs retry with exponential backoff"
  artifacts:
    - path: "app/worker/broker.py"
      provides: "Redis broker configuration"
      contains: "RedisBroker"
    - path: "app/worker/tasks.py"
      provides: "Base task decorator with retry logic"
      contains: "@dramatiq.actor"
    - path: "app/worker/status.py"
      provides: "Job status tracking in Redis"
      exports: ["JobStatus", "set_job_status", "get_job_status"]
  key_links:
    - from: "app/worker/tasks.py"
      to: "app/worker/broker.py"
      via: "uses configured broker"
      pattern: "from.*broker.*import"
---

<objective>
Set up Dramatiq job queue with Redis broker, retry logic, and job status tracking.

Purpose: Enable reliable background processing for document analysis. Jobs must survive failures with automatic retry and provide status visibility.

Output: Working Dramatiq setup with Redis broker, exponential backoff, and job status tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

Requirements this plan addresses:
- PROC-01: System uses Dramatiq for reliable job queue processing
- PROC-02: Jobs retry on failure with exponential backoff
- PROC-03: System supports job prioritization
- PROC-04: System provides job status tracking
- PROC-05: System handles graceful degradation on partial failures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Dramatiq with Redis broker</name>
  <files>app/worker/__init__.py, app/worker/broker.py</files>
  <action>
Set up Dramatiq with Redis broker.

app/worker/broker.py:
- Import dramatiq and RedisBroker from dramatiq.brokers.redis
- Read REDIS_URL from environment (default: redis://localhost:6379/0)
- Create broker = RedisBroker(url=REDIS_URL)
- Set dramatiq.set_broker(broker)
- Configure default queue and priority queues:
  - "default" - normal priority
  - "high" - high priority (for retries or urgent work)
  - "low" - low priority (for batch processing)

app/worker/__init__.py:
- Import broker to ensure it's configured on module load
- Re-export key components
  </action>
  <verify>python -c "from app.worker import broker"</verify>
  <done>Dramatiq broker configured with Redis and priority queues</done>
</task>

<task type="auto">
  <name>Task 2: Create middleware for retry and error handling</name>
  <files>app/worker/middleware.py</files>
  <action>
Create custom middleware for enhanced error handling.

app/worker/middleware.py:
- Import Middleware from dramatiq
- Import logging

Create RetryMiddleware class extending Middleware:
- Configure default retry settings:
  - max_retries: 3
  - min_backoff: 1000 (1 second)
  - max_backoff: 300000 (5 minutes)
  - backoff_factor: 2 (exponential)
- Override after_process_message to log failures
- Log retry attempts with attempt number and next retry time

Create StatusTrackingMiddleware class:
- Override before_process_message: set status to PROCESSING
- Override after_process_message: set status to COMPLETED or FAILED
- Use job message_id as key

Register middleware with broker in broker.py:
- Add RetryMiddleware
- Add StatusTrackingMiddleware
- Keep default Results middleware if using results backend

Import and configure in broker.py after broker creation.
  </action>
  <verify>python -c "from app.worker.middleware import RetryMiddleware, StatusTrackingMiddleware"</verify>
  <done>Middleware configured for retry with exponential backoff</done>
</task>

<task type="auto">
  <name>Task 3: Create job status tracking system</name>
  <files>app/worker/status.py, app/worker/tasks.py</files>
  <action>
Create job status tracking using Redis.

app/worker/status.py:
- Define JobStatus enum: QUEUED, PROCESSING, COMPLETED, FAILED
- Define JobInfo TypedDict or Pydantic model:
  - status: JobStatus
  - queued_at: datetime
  - started_at: datetime optional
  - completed_at: datetime optional
  - error: str optional
  - result: Any optional

Functions:
- set_job_status(job_id: str, status: JobStatus, **kwargs) -> None
  - Store in Redis with key "job:{job_id}"
  - Use JSON serialization
  - Set TTL of 7 days

- get_job_status(job_id: str) -> JobInfo | None
  - Retrieve from Redis
  - Return None if not found

- create_job(job_id: str) -> None
  - Initialize with QUEUED status and queued_at timestamp

app/worker/tasks.py:
- Create base_task decorator that wraps dramatiq.actor
- Configure default options:
  - max_retries=3
  - min_backoff=1000
  - max_backoff=300000
- Create example placeholder task for testing:
  @base_task(queue_name="default")
  def process_document(task_id: str) -> None:
      # Placeholder - will be implemented in Phase 2
      pass

Update app/worker/__init__.py to export status functions.
  </action>
  <verify>python -c "from app.worker.status import get_job_status, set_job_status, JobStatus"</verify>
  <done>Job status tracking via Redis with TTL expiration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Broker connects to Redis (redis-cli PING returns PONG)
- [ ] Middleware registered with broker
- [ ] Job status functions work with Redis
- [ ] Retry configuration uses exponential backoff
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Dramatiq workers can be started (dramatiq app.worker)
- Job status is trackable via Redis
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
