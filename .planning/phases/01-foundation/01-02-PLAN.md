---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [app/db/__init__.py, app/db/base.py, app/db/session.py, app/db/models/__init__.py, app/db/models/user.py, app/db/models/task.py, app/db/models/analysis.py, app/db/models/finding.py]
autonomous: true

must_haves:
  truths:
    - "SQLAlchemy models can be imported without database connection"
    - "Async session factory is configurable via environment"
    - "All models have proper relationships defined"
  artifacts:
    - path: "app/db/session.py"
      provides: "Async session factory and engine"
      exports: ["async_session_factory", "get_async_session"]
    - path: "app/db/models/user.py"
      provides: "User ORM model"
      contains: "class User"
    - path: "app/db/models/analysis.py"
      provides: "Analysis ORM model with relationships"
      contains: "relationship"
  key_links:
    - from: "app/db/models/__init__.py"
      to: "app/db/base.py"
      via: "imports Base"
      pattern: "from.*base.*import.*Base"
---

<objective>
Create SQLAlchemy 2.0 async ORM models that mirror the Pydantic schemas, with proper relationships and database session management.

Purpose: Establish the persistence layer with async-first design. Models map directly to PostgreSQL tables and enable efficient async database operations.

Output: Complete ORM layer with User, Task, Analysis, and Finding models, plus async session factory.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

Requirements this plan addresses:
- DATA-01: System stores analysis results in PostgreSQL
- DATA-02: System uses SQLAlchemy 2.0 with async support
- DATA-04: System stores user and authentication data
- DATA-05: System stores document metadata and storage references
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLAlchemy async session infrastructure</name>
  <files>app/db/__init__.py, app/db/base.py, app/db/session.py</files>
  <action>
Set up SQLAlchemy 2.0 async infrastructure.

app/db/base.py:
- Create declarative Base using SQLAlchemy 2.0 mapped_column style
- Create TimestampMixin with created_at, updated_at (server_default for created_at)
- Use uuid.uuid4 for primary keys
- Configure naming conventions for constraints (ix_, uq_, ck_, fk_, pk_)

app/db/session.py:
- Create async_engine using create_async_engine
- Use asyncpg as driver (postgresql+asyncpg://)
- Create async_session_factory using async_sessionmaker
- Create get_async_session as async generator for FastAPI dependency injection
- Read DATABASE_URL from environment (default to postgresql+asyncpg://postgres:postgres@localhost:5432/auditeng)
- Set echo=True only when DEBUG=true in environment

app/db/__init__.py:
- Re-export Base, async_session_factory, get_async_session
  </action>
  <verify>python -c "from app.db import Base, get_async_session"</verify>
  <done>Async session infrastructure importable and configurable</done>
</task>

<task type="auto">
  <name>Task 2: Create User and Task ORM models</name>
  <files>app/db/models/__init__.py, app/db/models/user.py, app/db/models/task.py</files>
  <action>
Create User and Task SQLAlchemy models using 2.0 style.

app/db/models/user.py - User model:
- id: UUID primary key (default uuid4)
- email: String(255), unique, indexed, not null
- hashed_password: String(255), not null
- is_active: Boolean, default True
- Inherit from Base and TimestampMixin
- Add relationship to tasks (one-to-many)
- Add __tablename__ = "users"

app/db/models/task.py - Task model:
- id: UUID primary key
- user_id: UUID, ForeignKey to users.id, indexed
- status: String(50), default "QUEUED"
- original_filename: String(255), not null
- file_path: String(500), nullable (storage path after upload)
- file_size: BigInteger, not null
- error_message: Text, nullable
- Inherit from Base and TimestampMixin
- Add relationship to user (many-to-one)
- Add relationship to analysis (one-to-one, optional)
- Add __tablename__ = "tasks"

app/db/models/__init__.py:
- Import and re-export User, Task
- Import Base from app.db.base
  </action>
  <verify>python -c "from app.db.models import User, Task"</verify>
  <done>User and Task models importable with proper relationships</done>
</task>

<task type="auto">
  <name>Task 3: Create Analysis and Finding ORM models</name>
  <files>app/db/models/analysis.py, app/db/models/finding.py</files>
  <action>
Create Analysis and Finding SQLAlchemy models.

app/db/models/analysis.py - Analysis model:
- id: UUID primary key
- task_id: UUID, ForeignKey to tasks.id, unique (one-to-one)
- equipment_type: String(50), not null
- test_type: String(50), not null
- equipment_tag: String(100), nullable
- verdict: String(50), nullable (APPROVED, REVIEW, REJECTED)
- compliance_score: Float, nullable (0-100)
- confidence_score: Float, nullable (0-1)
- extraction_result: JSON, nullable (stores ExtractionResult dict)
- validation_result: JSON, nullable (stores ValidationResult dict)
- Inherit from Base and TimestampMixin
- Add relationship to task (one-to-one, back_populates)
- Add relationship to findings (one-to-many)
- Add __tablename__ = "analyses"

app/db/models/finding.py - Finding model:
- id: UUID primary key
- analysis_id: UUID, ForeignKey to analyses.id, indexed
- severity: String(50), not null (CRITICAL, MAJOR, MINOR, INFO)
- rule_id: String(100), not null (e.g., "GND-01", "CAL-02")
- message: Text, not null
- evidence: JSON, nullable (stores FindingEvidence dict)
- remediation: Text, nullable
- Inherit from Base and TimestampMixin
- Add relationship to analysis (many-to-one, back_populates)
- Add __tablename__ = "findings"

Update app/db/models/__init__.py to export Analysis, Finding.
  </action>
  <verify>python -c "from app.db.models import Analysis, Finding"</verify>
  <done>Analysis and Finding models with relationships to Task</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All models import without error
- [ ] Relationships are bidirectional (back_populates)
- [ ] JSON columns use SQLAlchemy's JSON type
- [ ] Foreign keys have proper indexes
- [ ] No circular import issues
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Models match Pydantic schema structure
- Async session factory is properly configured
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
