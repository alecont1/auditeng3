---
phase: 01-foundation
plan: 05
type: execute
wave: 2
depends_on: ["01-01", "01-02", "01-04"]
files_modified: [app/main.py, app/api/__init__.py, app/api/health.py, app/core/__init__.py, app/core/exceptions.py, app/core/dependencies.py]
autonomous: true

must_haves:
  truths:
    - "FastAPI app starts without errors"
    - "Health endpoint returns 200 OK with status info"
    - "Database connection is validated on startup"
    - "Structured error responses for exceptions"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI application factory"
      contains: "FastAPI"
    - path: "app/api/health.py"
      provides: "Health check endpoint"
      contains: "@router.get"
    - path: "app/core/exceptions.py"
      provides: "Custom exception handlers"
      contains: "exception_handler"
  key_links:
    - from: "app/main.py"
      to: "app/api/health.py"
      via: "includes health router"
      pattern: "include_router"
    - from: "app/main.py"
      to: "app/db/session.py"
      via: "lifespan database check"
      pattern: "get_async_session"
---

<objective>
Create the FastAPI application with health endpoints, database session management, and error handling.

Purpose: Establish the HTTP layer that exposes the API. Health checks enable monitoring and deployment validation.

Output: Running FastAPI app with /health endpoint, proper error handling, and database connectivity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md

Requirements this plan addresses:
- Phase 1 Success Criteria: Basic health check endpoint returns 200 OK
- Phase 1 Success Criteria: Development environment runs with PostgreSQL + Redis
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI application with configuration</name>
  <files>app/main.py, app/config.py</files>
  <action>
Create the FastAPI application factory.

app/config.py (enhance if exists):
- Use pydantic-settings BaseSettings
- Define Settings class:
  - APP_NAME: str = "AuditEng"
  - APP_VERSION: str = "0.1.0"
  - DEBUG: bool = False
  - DATABASE_URL: str
  - REDIS_URL: str = "redis://localhost:6379/0"
  - CORS_ORIGINS: list[str] = ["http://localhost:3000"]
- Create get_settings() function with lru_cache

app/main.py:
- Import FastAPI
- Import settings from config
- Create lifespan context manager:
  - On startup: verify database connection (try a simple query)
  - On startup: log "AuditEng API starting"
  - On shutdown: log "AuditEng API shutting down"
- Create app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    lifespan=lifespan,
  )
- Add CORS middleware with settings.CORS_ORIGINS
- Include routers (health for now)

Do NOT add catch-all wildcard CORS - use explicit origins only.
  </action>
  <verify>python -c "from app.main import app; print(app.title)"</verify>
  <done>FastAPI app configured with settings and lifespan</done>
</task>

<task type="auto">
  <name>Task 2: Create health check endpoint</name>
  <files>app/api/__init__.py, app/api/health.py</files>
  <action>
Create health check router with database and Redis checks.

app/api/health.py:
- Create router = APIRouter(prefix="/health", tags=["health"])
- Define HealthResponse Pydantic model:
  - status: str ("healthy" or "degraded")
  - version: str
  - database: str ("connected" or "disconnected")
  - redis: str ("connected" or "disconnected")
  - timestamp: datetime

- Create GET /health endpoint:
  - Check database: try to execute "SELECT 1"
  - Check Redis: try to ping
  - Return HealthResponse with component status
  - Return 200 if database OK, 503 if database down
  - Redis can be down and still return 200 (degraded mode)

- Create GET /health/live endpoint:
  - Simple liveness check (always returns 200)
  - Used by container orchestrators

- Create GET /health/ready endpoint:
  - Readiness check (returns 200 only if database connected)
  - Used for traffic routing

app/api/__init__.py:
- Import and expose health router
  </action>
  <verify>Run uvicorn app.main:app and curl http://localhost:8000/health</verify>
  <done>Health endpoints available at /health, /health/live, /health/ready</done>
</task>

<task type="auto">
  <name>Task 3: Create exception handling and dependencies</name>
  <files>app/core/__init__.py, app/core/exceptions.py, app/core/dependencies.py</files>
  <action>
Create structured error handling and common dependencies.

app/core/exceptions.py:
- Define base AuditEngException(Exception) with:
  - status_code: int
  - detail: str
  - error_code: str (e.g., "AUTH_001", "VALIDATION_001")

- Define specific exceptions:
  - NotFoundError(AuditEngException): status_code=404
  - ValidationError(AuditEngException): status_code=422
  - AuthenticationError(AuditEngException): status_code=401
  - AuthorizationError(AuditEngException): status_code=403
  - ExternalServiceError(AuditEngException): status_code=503

- Define ErrorResponse Pydantic model:
  - error_code: str
  - detail: str
  - timestamp: datetime

- Create exception_handler function for FastAPI:
  - Register for AuditEngException
  - Return JSONResponse with ErrorResponse

- Create generic_exception_handler for unhandled exceptions:
  - Log the full traceback
  - Return 500 with generic message (don't leak internals)

Register handlers in app/main.py.

app/core/dependencies.py:
- Create get_db dependency using get_async_session
- Create get_settings dependency using get_settings function
- These will be used by API endpoints

app/core/__init__.py:
- Export exceptions and dependencies
  </action>
  <verify>python -c "from app.core.exceptions import NotFoundError; raise NotFoundError('test')" (should raise)</verify>
  <done>Structured exceptions with error codes and handlers registered</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] uvicorn app.main:app starts without errors
- [ ] GET /health returns JSON with status info
- [ ] GET /health/live returns 200
- [ ] GET /health/ready returns 200 when database connected
- [ ] Custom exceptions return structured JSON responses
- [ ] CORS is configured (not wildcard)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- API is accessible and returns proper responses
- Error handling is consistent and structured
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
