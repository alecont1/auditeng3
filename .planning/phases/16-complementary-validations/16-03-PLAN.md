---
phase: 16-complementary-validations
plan: 03
type: execute
wave: 2
depends_on: ["16-01", "16-02"]
files_modified:
  - app/core/validation/complementary.py
  - app/core/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "ComplementaryValidator detects CALIBRATION_EXPIRED when calibration date < inspection date"
    - "ComplementaryValidator detects SERIAL_MISMATCH when OCR serial != report serial"
    - "ComplementaryValidator flags SERIAL_ILLEGIBLE when OCR confidence < threshold"
    - "All findings use CRITICAL severity for blockers, MAJOR for low confidence"
  artifacts:
    - path: "app/core/validation/complementary.py"
      provides: "ComplementaryValidator with calibration and serial checks"
      exports: ["ComplementaryValidator"]
      min_lines: 100
  key_links:
    - from: "app/core/validation/complementary.py"
      to: "app/core/validation/base.py"
      via: "class inheritance"
      pattern: "class ComplementaryValidator\\(BaseValidator\\)"
    - from: "app/core/validation/complementary.py"
      to: "app/core/extraction/ocr.py"
      via: "OCR result types"
      pattern: "CertificateOCRResult"
---

<objective>
Implement ComplementaryValidator with CALIBRATION_EXPIRED and SERIAL_MISMATCH checks.

Purpose: These two validators check cross-references between report data and certificate photos. CALIBRATION_EXPIRED compares calibration expiration vs inspection date. SERIAL_MISMATCH compares camera serial from report vs OCR from certificate photo.

Output: ComplementaryValidator class extending BaseValidator with deterministic validation methods for calibration and serial checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/16-complementary-validations/16-CONTEXT.md
@.planning/phases/16-complementary-validations/16-RESEARCH.md

# Validator patterns
@app/core/validation/base.py
@app/core/validation/calibration.py
@app/core/validation/schemas.py
@app/core/validation/config.py

# OCR from Plan 01
# (Will exist after 16-01 completes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ComplementaryValidator base with calibration check</name>
  <files>app/core/validation/complementary.py</files>
  <action>
Create ComplementaryValidator class extending BaseValidator:

```python
"""Complementary validators for cross-validation rules.

These validators complement test-type specific validators by checking
cross-references between report data and supporting evidence (photos,
certificates, etc.).

Per CONTEXT.md decisions:
- Run ALL validations and aggregate findings (no short-circuit)
- CRITICAL severity for blockers, MAJOR for low confidence flags
- "IA extrai, codigo valida" - OCR extraction happens before validation
"""

from datetime import date, datetime
from typing import Any

from app.core.extraction.ocr import CertificateOCRResult, HygrometerOCRResult
from app.core.extraction.schemas import BaseExtractionResult
from app.core.extraction.thermography import ThermographyExtractionResult
from app.core.validation.base import BaseValidator
from app.core.validation.schemas import Finding, ValidationResult, ValidationSeverity


class ComplementaryValidator(BaseValidator):
    """Validator for cross-validation rules.

    Checks cross-references between report data and supporting evidence.
    Requires OCR data to be pre-extracted before validation.

    Validators:
    - CALIBRATION_EXPIRED: calibration.expiration_date < inspection_date
    - SERIAL_MISMATCH: camera_serial != certificate OCR serial
    - VALUE_MISMATCH: reflected_temp != hygrometer OCR reading
    - PHOTO_MISSING: phases without thermal images
    - SPEC_NON_COMPLIANCE: delta > 10C without required comments
    """

    @property
    def test_type(self) -> str:
        return "complementary"

    def validate(
        self,
        extraction: BaseExtractionResult,
        certificate_ocr: CertificateOCRResult | None = None,
        hygrometer_ocr: HygrometerOCRResult | None = None,
        report_comments: str | None = None,
        expected_phases: list[str] | None = None,
    ) -> ValidationResult:
        """Validate extraction with optional OCR data.

        Args:
            extraction: The extraction result to validate.
            certificate_ocr: OCR result from calibration certificate photo.
            hygrometer_ocr: OCR result from thermo-hygrometer photo.
            report_comments: Comments section text from report.
            expected_phases: List of expected phase identifiers.

        Returns:
            ValidationResult with complementary validation findings.
        """
        findings: list[Finding] = []

        # Only run thermography-specific validations for thermography extractions
        if isinstance(extraction, ThermographyExtractionResult):
            self._check_calibration_expired(findings, extraction)

            if certificate_ocr:
                self._check_serial_mismatch(findings, extraction, certificate_ocr)

            # Placeholder methods for future plans
            # if hygrometer_ocr:
            #     self._check_value_mismatch(findings, extraction, hygrometer_ocr)
            # if expected_phases:
            #     self._check_photo_missing(findings, extraction, expected_phases)
            # self._check_spec_compliance(findings, extraction, report_comments)

        equipment_tag = None
        if hasattr(extraction, "equipment"):
            equipment_tag = extraction.equipment.equipment_tag.value

        return self.create_result(findings, equipment_tag=equipment_tag)

    def _parse_date(self, date_value: Any) -> date | None:
        """Parse date from various formats."""
        if isinstance(date_value, date):
            return date_value
        if isinstance(date_value, datetime):
            return date_value.date()
        if isinstance(date_value, str):
            # Try multiple formats
            for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y", "%Y/%m/%d"]:
                try:
                    return datetime.strptime(date_value, fmt).date()
                except ValueError:
                    continue
            # Try ISO format with potential timezone
            try:
                return datetime.fromisoformat(date_value.replace("/", "-")).date()
            except ValueError:
                return None
        return None

    def _check_calibration_expired(
        self,
        findings: list[Finding],
        extraction: ThermographyExtractionResult,
    ) -> None:
        """Check if calibration was expired at time of inspection.

        This differs from CalibrationValidator which checks against today.
        This checks calibration.expiration_date vs test_conditions.inspection_date.
        """
        calibration = extraction.calibration
        if not calibration or not calibration.expiration_date:
            return  # Handled by CalibrationValidator

        exp_date_value = calibration.expiration_date.value
        if not exp_date_value:
            return

        inspection_date_value = extraction.test_conditions.inspection_date.value
        if not inspection_date_value:
            return

        exp_date = self._parse_date(exp_date_value)
        insp_date = self._parse_date(inspection_date_value)

        if exp_date is None or insp_date is None:
            return  # Can't compare if dates don't parse

        if exp_date < insp_date:
            days_expired = (insp_date - exp_date).days
            self.add_finding(
                findings=findings,
                rule_id="COMP-001",
                severity=ValidationSeverity.CRITICAL,
                message=(
                    f"Calibration expired {days_expired} days before inspection: "
                    f"certificate expired {exp_date}, inspection on {insp_date}"
                ),
                field_path="calibration.expiration_date",
                extracted_value=str(exp_date),
                threshold=f">= {insp_date}",
                standard_reference="ISO/IEC 17025",
                remediation="Recalibrate instrument before use. Test results invalid.",
            )

    def _check_serial_mismatch(
        self,
        findings: list[Finding],
        extraction: ThermographyExtractionResult,
        certificate_ocr: CertificateOCRResult,
    ) -> None:
        """Compare serial number from report vs OCR from certificate photo."""
        config = self.config.complementary

        report_serial = extraction.test_conditions.camera_serial
        if not report_serial or not report_serial.value:
            return  # No serial in report to compare

        photo_serial = certificate_ocr.serial_number
        if not photo_serial or not photo_serial.value:
            return  # OCR didn't extract serial

        # Check OCR confidence first
        if photo_serial.confidence < config.serial_confidence_threshold:
            self.add_finding(
                findings=findings,
                rule_id="COMP-006",
                severity=ValidationSeverity.MAJOR,  # Not a blocker - needs review
                message=(
                    f"Serial number illegible in certificate photo "
                    f"(confidence: {photo_serial.confidence:.0%})"
                ),
                field_path="certificate.serial_number",
                extracted_value=str(photo_serial.value),
                threshold=f"confidence >= {config.serial_confidence_threshold:.0%}",
                standard_reference=config.standard_reference,
                remediation="Manual verification required - cannot read serial clearly",
            )
            return  # Don't compare if low confidence

        # Normalize for comparison (strip whitespace, uppercase)
        report_val = str(report_serial.value).strip().upper()
        photo_val = str(photo_serial.value).strip().upper()

        if report_val != photo_val:
            self.add_finding(
                findings=findings,
                rule_id="COMP-002",
                severity=ValidationSeverity.CRITICAL,
                message=(
                    f"Serial number mismatch: report='{report_val}', "
                    f"certificate photo='{photo_val}'"
                ),
                field_path="test_conditions.camera_serial",
                extracted_value=report_val,
                threshold=f"Expected: {photo_val}",
                standard_reference=config.standard_reference,
                remediation="Verify correct calibration certificate is attached to report",
            )
```

Export from `app/core/validation/__init__.py`.
  </action>
  <verify>
```bash
cd /home/xande && python -c "
from app.core.validation.complementary import ComplementaryValidator
from app.core.validation import ComplementaryValidator as CV2
assert ComplementaryValidator == CV2
print('ComplementaryValidator imports OK')
"
```
  </verify>
  <done>ComplementaryValidator class exists with _check_calibration_expired and _check_serial_mismatch methods</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for calibration and serial validators</name>
  <files>app/tests/validation/test_complementary.py</files>
  <action>
Create comprehensive unit tests for ComplementaryValidator:

```python
"""Tests for ComplementaryValidator."""

import pytest
from datetime import date

from app.core.extraction.ocr import CertificateOCRResult
from app.core.extraction.schemas import CalibrationInfo, EquipmentInfo, FieldConfidence
from app.core.extraction.thermography import (
    ThermographyExtractionResult,
    ThermalImageData,
    ThermographyTestConditions,
)
from app.core.validation.complementary import ComplementaryValidator
from app.core.validation import ValidationSeverity


@pytest.fixture
def validator():
    return ComplementaryValidator()


@pytest.fixture
def basic_equipment():
    return EquipmentInfo(
        equipment_tag=FieldConfidence(value="QD-01", confidence=0.9),
        equipment_type=FieldConfidence(value="panel", confidence=0.9),
    )


@pytest.fixture
def basic_thermal_data():
    return ThermalImageData()


def create_extraction(
    equipment,
    thermal_data,
    inspection_date: str,
    calibration_exp: str | None = None,
    camera_serial: str | None = None,
) -> ThermographyExtractionResult:
    """Helper to create test extraction."""
    calibration = None
    if calibration_exp:
        calibration = CalibrationInfo(
            expiration_date=FieldConfidence(value=calibration_exp, confidence=0.9),
        )

    test_conditions = ThermographyTestConditions(
        inspection_date=FieldConfidence(value=inspection_date, confidence=0.9),
        camera_serial=FieldConfidence(value=camera_serial, confidence=0.9) if camera_serial else None,
    )

    return ThermographyExtractionResult(
        equipment=equipment,
        calibration=calibration,
        test_conditions=test_conditions,
        thermal_data=thermal_data,
        hotspots=[],
        overall_confidence=0.9,
    )


class TestCalibrationExpired:
    """Tests for CALIBRATION_EXPIRED (COMP-001)."""

    def test_calibration_expired_before_inspection(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Calibration expired before inspection -> CRITICAL."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            calibration_exp="2024-06-01",  # Expired 14 days before
        )

        result = validator.validate(extraction)

        assert not result.is_valid
        assert result.critical_count == 1
        finding = result.findings[0]
        assert finding.rule_id == "COMP-001"
        assert finding.severity == ValidationSeverity.CRITICAL
        assert "14 days before inspection" in finding.message

    def test_calibration_valid_at_inspection(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Calibration valid at inspection -> no finding."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            calibration_exp="2024-12-31",  # Valid until end of year
        )

        result = validator.validate(extraction)

        comp001_findings = [f for f in result.findings if f.rule_id == "COMP-001"]
        assert len(comp001_findings) == 0

    def test_calibration_expires_same_day(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Calibration expires same day as inspection -> valid (not expired)."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            calibration_exp="2024-06-15",  # Same day
        )

        result = validator.validate(extraction)

        comp001_findings = [f for f in result.findings if f.rule_id == "COMP-001"]
        assert len(comp001_findings) == 0

    def test_no_calibration_info(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """No calibration info -> no finding (handled by CalibrationValidator)."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            calibration_exp=None,
        )

        result = validator.validate(extraction)

        assert result.critical_count == 0


class TestSerialMismatch:
    """Tests for SERIAL_MISMATCH (COMP-002)."""

    def test_serial_mismatch(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Serial mismatch -> CRITICAL."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial="ABC123",
        )
        certificate_ocr = CertificateOCRResult(
            serial_number=FieldConfidence(value="XYZ789", confidence=0.95),
        )

        result = validator.validate(extraction, certificate_ocr=certificate_ocr)

        assert not result.is_valid
        assert result.critical_count == 1
        finding = result.findings[0]
        assert finding.rule_id == "COMP-002"
        assert finding.severity == ValidationSeverity.CRITICAL
        assert "ABC123" in finding.message
        assert "XYZ789" in finding.message

    def test_serial_match(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Serial matches -> no finding."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial="ABC123",
        )
        certificate_ocr = CertificateOCRResult(
            serial_number=FieldConfidence(value="ABC123", confidence=0.95),
        )

        result = validator.validate(extraction, certificate_ocr=certificate_ocr)

        comp002_findings = [f for f in result.findings if f.rule_id == "COMP-002"]
        assert len(comp002_findings) == 0

    def test_serial_match_case_insensitive(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Serial comparison is case-insensitive."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial="abc123",
        )
        certificate_ocr = CertificateOCRResult(
            serial_number=FieldConfidence(value="ABC123", confidence=0.95),
        )

        result = validator.validate(extraction, certificate_ocr=certificate_ocr)

        comp002_findings = [f for f in result.findings if f.rule_id == "COMP-002"]
        assert len(comp002_findings) == 0

    def test_serial_illegible_low_confidence(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Low OCR confidence -> MAJOR (SERIAL_ILLEGIBLE), not comparison."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial="ABC123",
        )
        certificate_ocr = CertificateOCRResult(
            serial_number=FieldConfidence(value="A?C1?3", confidence=0.5),  # Low confidence
        )

        result = validator.validate(extraction, certificate_ocr=certificate_ocr)

        # Should get SERIAL_ILLEGIBLE, not SERIAL_MISMATCH
        comp006_findings = [f for f in result.findings if f.rule_id == "COMP-006"]
        comp002_findings = [f for f in result.findings if f.rule_id == "COMP-002"]
        assert len(comp006_findings) == 1
        assert len(comp002_findings) == 0
        assert comp006_findings[0].severity == ValidationSeverity.MAJOR

    def test_no_serial_in_report(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """No serial in report -> no comparison."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial=None,
        )
        certificate_ocr = CertificateOCRResult(
            serial_number=FieldConfidence(value="XYZ789", confidence=0.95),
        )

        result = validator.validate(extraction, certificate_ocr=certificate_ocr)

        serial_findings = [f for f in result.findings if "COMP-002" in f.rule_id or "COMP-006" in f.rule_id]
        assert len(serial_findings) == 0

    def test_no_ocr_result(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """No OCR result -> no comparison."""
        extraction = create_extraction(
            basic_equipment,
            basic_thermal_data,
            inspection_date="2024-06-15",
            camera_serial="ABC123",
        )

        result = validator.validate(extraction, certificate_ocr=None)

        serial_findings = [f for f in result.findings if "COMP-002" in f.rule_id or "COMP-006" in f.rule_id]
        assert len(serial_findings) == 0
```
  </action>
  <verify>
```bash
cd /home/xande && python -m pytest app/tests/validation/test_complementary.py -v
```
  </verify>
  <done>All unit tests for calibration and serial validators pass</done>
</task>

</tasks>

<verification>
```bash
# Validator imports and works
cd /home/xande && python -c "
from app.core.validation.complementary import ComplementaryValidator
from app.core.validation import ComplementaryValidator as CV
from app.core.validation.schemas import ValidationSeverity
v = ComplementaryValidator()
print(f'test_type: {v.test_type}')
print('ComplementaryValidator ready')
"

# Tests pass
cd /home/xande && python -m pytest app/tests/validation/test_complementary.py -v
```
</verification>

<success_criteria>
- ComplementaryValidator extends BaseValidator correctly
- _check_calibration_expired compares expiration vs inspection date
- _check_serial_mismatch compares report serial vs OCR serial (case-insensitive)
- Low confidence OCR creates SERIAL_ILLEGIBLE (MAJOR) not SERIAL_MISMATCH
- All findings use correct severity (CRITICAL for blockers)
- Unit tests cover all edge cases and pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-complementary-validations/16-03-SUMMARY.md`
</output>
