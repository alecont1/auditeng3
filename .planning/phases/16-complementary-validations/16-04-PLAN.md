---
phase: 16-complementary-validations
plan: 04
type: execute
wave: 2
depends_on: ["16-01", "16-02"]
files_modified:
  - app/core/validation/complementary.py
  - app/tests/validation/test_complementary.py
autonomous: true

must_haves:
  truths:
    - "ComplementaryValidator detects VALUE_MISMATCH when reflected temp differs from hygrometer"
    - "ComplementaryValidator detects PHOTO_MISSING when phases lack thermal images"
    - "ComplementaryValidator detects SPEC_NON_COMPLIANCE when delta > 10C without comments"
    - "All validators aggregate findings (no short-circuit)"
  artifacts:
    - path: "app/core/validation/complementary.py"
      provides: "Complete ComplementaryValidator with all 5 checks"
      exports: ["ComplementaryValidator"]
      contains: "_check_value_mismatch"
  key_links:
    - from: "app/core/validation/complementary.py"
      to: "app/core/extraction/ocr.py"
      via: "HygrometerOCRResult type"
      pattern: "HygrometerOCRResult"
---

<objective>
Complete ComplementaryValidator with VALUE_MISMATCH, PHOTO_MISSING, and SPEC_NON_COMPLIANCE checks.

Purpose: Complete the remaining 3 validators. VALUE_MISMATCH compares reflected temperature vs hygrometer OCR. PHOTO_MISSING checks that all expected phases have thermal images. SPEC_NON_COMPLIANCE verifies that high delta-T readings have required documentation.

Output: Fully functional ComplementaryValidator with all 5 cross-validation rules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/16-complementary-validations/16-CONTEXT.md
@.planning/phases/16-complementary-validations/16-RESEARCH.md

# Validator base (after 16-03)
# @app/core/validation/complementary.py (partial)

# OCR types (after 16-01)
# @app/core/extraction/ocr.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add VALUE_MISMATCH validator</name>
  <files>app/core/validation/complementary.py</files>
  <action>
Add _check_value_mismatch method to ComplementaryValidator:

```python
def _check_value_mismatch(
    self,
    findings: list[Finding],
    extraction: ThermographyExtractionResult,
    hygrometer_ocr: HygrometerOCRResult,
) -> None:
    """Compare reflected temperature from report vs hygrometer photo.

    Per CONTEXT.md:
    - Primary: Compare reflected temp in report vs OCR from thermo-hygrometer photo
    - Fallback: If ALL reflected temps are identical, flag as suspicious copy-paste
    """
    config = self.config.complementary

    # Get reflected temperature from thermal data
    thermal_data = extraction.thermal_data
    if not thermal_data.reflected_temperature:
        return  # No reflected temp in report

    report_temp = thermal_data.reflected_temperature.value
    if report_temp is None:
        return

    # Get temperature from hygrometer OCR
    hygrometer_temp = hygrometer_ocr.ambient_temperature
    if not hygrometer_temp or hygrometer_temp.value is None:
        return  # OCR didn't extract temperature

    try:
        report_val = float(report_temp)
        ocr_val = float(hygrometer_temp.value)
    except (ValueError, TypeError):
        return  # Can't compare non-numeric values

    # Check if difference exceeds tolerance
    diff = abs(report_val - ocr_val)
    if diff > config.temp_match_tolerance:
        self.add_finding(
            findings=findings,
            rule_id="COMP-003",
            severity=ValidationSeverity.CRITICAL,
            message=(
                f"Reflected temperature mismatch: report={report_val}C, "
                f"hygrometer photo={ocr_val}C (diff={diff:.1f}C, tolerance={config.temp_match_tolerance}C)"
            ),
            field_path="thermal_data.reflected_temperature",
            extracted_value=report_val,
            threshold=f"{ocr_val} +/- {config.temp_match_tolerance}C",
            standard_reference=config.standard_reference,
            remediation="Verify reflected temperature matches actual ambient conditions",
        )
```

Update the validate() method to call _check_value_mismatch when hygrometer_ocr is provided (uncomment the placeholder).
  </action>
  <verify>
```bash
cd /home/xande && python -c "
from app.core.validation.complementary import ComplementaryValidator
v = ComplementaryValidator()
assert hasattr(v, '_check_value_mismatch')
print('VALUE_MISMATCH validator added')
"
```
  </verify>
  <done>_check_value_mismatch method implemented comparing reflected temp vs hygrometer OCR</done>
</task>

<task type="auto">
  <name>Task 2: Add PHOTO_MISSING and SPEC_NON_COMPLIANCE validators</name>
  <files>app/core/validation/complementary.py</files>
  <action>
Add _check_photo_missing and _check_spec_compliance methods:

```python
def _check_photo_missing(
    self,
    findings: list[Finding],
    extraction: ThermographyExtractionResult,
    expected_phases: list[str],
) -> None:
    """Check that all expected phases have corresponding thermal images.

    Per CONTEXT.md:
    - Parse report structure to find which phases SHOULD exist
    - Compare against hotspots which represent actual thermal images
    """
    if not expected_phases:
        return

    # Extract phases that have thermal images from hotspots
    documented_phases = set()
    for hotspot in extraction.hotspots:
        if hotspot.location and hotspot.location.value:
            # Normalize: "Phase A", "Fase A", "A" -> "A"
            location = str(hotspot.location.value).upper()
            for phase in ["A", "B", "C", "N"]:  # Common phase designations
                if phase in location:
                    documented_phases.add(phase)

    # Also check common patterns like "R", "S", "T" (Brazilian)
    for hotspot in extraction.hotspots:
        if hotspot.location and hotspot.location.value:
            location = str(hotspot.location.value).upper()
            for phase in ["R", "S", "T"]:
                if phase in location:
                    documented_phases.add(phase)

    # Normalize expected phases
    expected_normalized = set()
    for phase in expected_phases:
        phase_upper = phase.upper()
        for p in ["A", "B", "C", "N", "R", "S", "T"]:
            if p in phase_upper:
                expected_normalized.add(p)

    # Find missing phases
    missing = expected_normalized - documented_phases
    if missing:
        missing_str = ", ".join(sorted(missing))
        self.add_finding(
            findings=findings,
            rule_id="COMP-004",
            severity=ValidationSeverity.CRITICAL,
            message=f"Thermal images missing for phase(s): {missing_str}",
            field_path="hotspots",
            extracted_value=sorted(documented_phases),
            threshold=f"Expected phases: {sorted(expected_normalized)}",
            standard_reference=self.config.complementary.standard_reference,
            remediation="Include thermal images for all phases being tested",
        )

def _check_spec_compliance(
    self,
    findings: list[Finding],
    extraction: ThermographyExtractionResult,
    report_comments: str | None,
) -> None:
    """Check SPEC compliance: delta > 10C must have required comments.

    Per CONTEXT.md:
    - Triggered when delta-T > 10C (Microsoft standard)
    - Check for keywords in COMMENTS section: terminals, insulators, torque, conductors
    - Section must exist AND contain relevant keywords
    """
    config = self.config.complementary

    # Find hotspots exceeding SPEC threshold
    exceeding_hotspots = []
    for hotspot in extraction.hotspots:
        if hotspot.delta_t and hotspot.delta_t > config.spec_delta_t_threshold:
            exceeding_hotspots.append(hotspot)

    if not exceeding_hotspots:
        return  # No hotspots exceed threshold

    # Check if comments exist and contain required keywords
    if not report_comments:
        locations = [h.location.value for h in exceeding_hotspots if h.location]
        self.add_finding(
            findings=findings,
            rule_id="COMP-005",
            severity=ValidationSeverity.CRITICAL,
            message=(
                f"SPEC non-compliance: {len(exceeding_hotspots)} hotspot(s) with "
                f"delta-T > {config.spec_delta_t_threshold}C but no comments section found"
            ),
            field_path="comments",
            extracted_value=None,
            threshold=f"Required keywords: {config.spec_required_keywords[:4]}...",
            standard_reference=config.standard_reference,
            remediation="Add comments section addressing high delta-T findings",
        )
        return

    # Check for required keywords (case-insensitive)
    comments_lower = report_comments.lower()
    found_keywords = [
        kw for kw in config.spec_required_keywords
        if kw.lower() in comments_lower
    ]

    if not found_keywords:
        self.add_finding(
            findings=findings,
            rule_id="COMP-005",
            severity=ValidationSeverity.CRITICAL,
            message=(
                f"SPEC non-compliance: delta-T > {config.spec_delta_t_threshold}C "
                f"but comments lack required keywords"
            ),
            field_path="comments",
            extracted_value=report_comments[:100] + "..." if len(report_comments) > 100 else report_comments,
            threshold=f"Must contain: {config.spec_required_keywords[:4]}",
            standard_reference=config.standard_reference,
            remediation="Comments must address: terminals, insulators, torque, or conductors",
        )
```

Update validate() method to call these methods (uncomment placeholders):
- _check_photo_missing when expected_phases is provided
- _check_spec_compliance always for thermography extractions with hotspots
  </action>
  <verify>
```bash
cd /home/xande && python -c "
from app.core.validation.complementary import ComplementaryValidator
v = ComplementaryValidator()
assert hasattr(v, '_check_photo_missing')
assert hasattr(v, '_check_spec_compliance')
print('PHOTO_MISSING and SPEC_NON_COMPLIANCE validators added')
"
```
  </verify>
  <done>_check_photo_missing and _check_spec_compliance methods implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for remaining validators</name>
  <files>app/tests/validation/test_complementary.py</files>
  <action>
Add test classes for VALUE_MISMATCH, PHOTO_MISSING, and SPEC_NON_COMPLIANCE to the existing test file:

```python
# Add to existing test_complementary.py

from app.core.extraction.ocr import HygrometerOCRResult
from app.core.extraction.thermography import Hotspot


def create_hotspot(location: str, max_temp: float, ref_temp: float) -> Hotspot:
    """Helper to create hotspot with delta-T."""
    return Hotspot(
        location=FieldConfidence(value=location, confidence=0.9),
        max_temperature=FieldConfidence(value=max_temp, confidence=0.9),
        reference_temperature=FieldConfidence(value=ref_temp, confidence=0.9),
    )


class TestValueMismatch:
    """Tests for VALUE_MISMATCH (COMP-003)."""

    def test_temperature_mismatch(
        self, validator, basic_equipment
    ):
        """Temperature differs by more than tolerance -> CRITICAL."""
        thermal_data = ThermalImageData(
            reflected_temperature=FieldConfidence(value=25.0, confidence=0.9),
        )
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=thermal_data,
            hotspots=[],
            overall_confidence=0.9,
        )
        hygrometer_ocr = HygrometerOCRResult(
            ambient_temperature=FieldConfidence(value=30.0, confidence=0.95),  # 5C diff
        )

        result = validator.validate(extraction, hygrometer_ocr=hygrometer_ocr)

        comp003_findings = [f for f in result.findings if f.rule_id == "COMP-003"]
        assert len(comp003_findings) == 1
        assert comp003_findings[0].severity == ValidationSeverity.CRITICAL

    def test_temperature_within_tolerance(
        self, validator, basic_equipment
    ):
        """Temperature within tolerance -> no finding."""
        thermal_data = ThermalImageData(
            reflected_temperature=FieldConfidence(value=25.0, confidence=0.9),
        )
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=thermal_data,
            hotspots=[],
            overall_confidence=0.9,
        )
        hygrometer_ocr = HygrometerOCRResult(
            ambient_temperature=FieldConfidence(value=26.0, confidence=0.95),  # 1C diff
        )

        result = validator.validate(extraction, hygrometer_ocr=hygrometer_ocr)

        comp003_findings = [f for f in result.findings if f.rule_id == "COMP-003"]
        assert len(comp003_findings) == 0


class TestPhotoMissing:
    """Tests for PHOTO_MISSING (COMP-004)."""

    def test_missing_phase(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Missing phase thermal image -> CRITICAL."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Phase A", 35.0, 30.0),
                create_hotspot("Phase C", 36.0, 30.0),
                # Phase B missing
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(
            extraction,
            expected_phases=["Phase A", "Phase B", "Phase C"],
        )

        comp004_findings = [f for f in result.findings if f.rule_id == "COMP-004"]
        assert len(comp004_findings) == 1
        assert "B" in comp004_findings[0].message

    def test_all_phases_present(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """All phases have thermal images -> no finding."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Phase A", 35.0, 30.0),
                create_hotspot("Phase B", 34.0, 30.0),
                create_hotspot("Phase C", 36.0, 30.0),
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(
            extraction,
            expected_phases=["Phase A", "Phase B", "Phase C"],
        )

        comp004_findings = [f for f in result.findings if f.rule_id == "COMP-004"]
        assert len(comp004_findings) == 0


class TestSpecNonCompliance:
    """Tests for SPEC_NON_COMPLIANCE (COMP-005)."""

    def test_high_delta_no_comments(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Delta > 10C without comments -> CRITICAL."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Breaker 1", 45.0, 30.0),  # 15C delta
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(extraction, report_comments=None)

        comp005_findings = [f for f in result.findings if f.rule_id == "COMP-005"]
        assert len(comp005_findings) == 1
        assert comp005_findings[0].severity == ValidationSeverity.CRITICAL

    def test_high_delta_with_valid_comments(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Delta > 10C with proper comments -> no finding."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Breaker 1", 45.0, 30.0),  # 15C delta
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(
            extraction,
            report_comments="Loose terminals identified. Torque check recommended.",
        )

        comp005_findings = [f for f in result.findings if f.rule_id == "COMP-005"]
        assert len(comp005_findings) == 0

    def test_high_delta_irrelevant_comments(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Delta > 10C with irrelevant comments -> CRITICAL."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Breaker 1", 45.0, 30.0),  # 15C delta
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(
            extraction,
            report_comments="Weather was sunny. Equipment looked fine.",
        )

        comp005_findings = [f for f in result.findings if f.rule_id == "COMP-005"]
        assert len(comp005_findings) == 1

    def test_delta_below_threshold(
        self, validator, basic_equipment, basic_thermal_data
    ):
        """Delta <= 10C -> no SPEC check needed."""
        extraction = ThermographyExtractionResult(
            equipment=basic_equipment,
            test_conditions=ThermographyTestConditions(
                inspection_date=FieldConfidence(value="2024-06-15", confidence=0.9),
            ),
            thermal_data=basic_thermal_data,
            hotspots=[
                create_hotspot("Breaker 1", 38.0, 30.0),  # 8C delta
            ],
            overall_confidence=0.9,
        )

        result = validator.validate(extraction, report_comments=None)

        comp005_findings = [f for f in result.findings if f.rule_id == "COMP-005"]
        assert len(comp005_findings) == 0
```
  </action>
  <verify>
```bash
cd /home/xande && python -m pytest app/tests/validation/test_complementary.py -v
```
  </verify>
  <done>All unit tests for VALUE_MISMATCH, PHOTO_MISSING, and SPEC_NON_COMPLIANCE pass</done>
</task>

</tasks>

<verification>
```bash
# All validator methods exist
cd /home/xande && python -c "
from app.core.validation.complementary import ComplementaryValidator
v = ComplementaryValidator()
methods = ['_check_calibration_expired', '_check_serial_mismatch', '_check_value_mismatch', '_check_photo_missing', '_check_spec_compliance']
for m in methods:
    assert hasattr(v, m), f'Missing method: {m}'
print('All 5 validator methods present')
"

# All tests pass
cd /home/xande && python -m pytest app/tests/validation/test_complementary.py -v

# Existing tests still pass
cd /home/xande && python -m pytest app/tests/validation/ -v --ignore=app/tests/validation/test_complementary.py
```
</verification>

<success_criteria>
- _check_value_mismatch compares reflected temp vs hygrometer with configurable tolerance
- _check_photo_missing identifies missing phase thermal images
- _check_spec_compliance checks for required keywords when delta > threshold
- All validators use CRITICAL severity for blockers
- Unit tests cover normal, boundary, and edge cases
- Existing validation tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-complementary-validations/16-04-SUMMARY.md`
</output>
